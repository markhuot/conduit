# Routing Architecture Specification

**Spec ID**: 2025120801  
**Created**: 2025-12-08  
**Status**: Draft  
**Phase**: Foundation

## Overview

This spec defines the routing architecture for Project Conduit, establishing clear separation between backend API routing and frontend UI code. The backend must be framework-agnostic and capable of running independently, while supporting multiple frontend frameworks (React, Vue, etc.).

The routing pattern established here applies to both HTTP API routes and CLI commands, providing a consistent interface for both web and command-line interactions.

## Design Principles

1. **Complete Separation**: Backend and frontend are independently deployable
2. **Framework Agnostic Backend**: Core API routing has zero frontend dependencies
3. **Standard Interfaces**: REST/JSON API following web standards
4. **Type Safety**: Full TypeScript support with shared type definitions
5. **Development Experience**: Simple local development with hot reload

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        View Layer                            â”‚
â”‚                   (src/ui/ - .tsx or .vue)                   â”‚
â”‚                      (Port 5173)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Framework-agnostic UI components                      â”‚ â”‚
â”‚  â”‚  - React (.tsx) or Vue (.vue) components               â”‚ â”‚
â”‚  â”‚  - Shares top-level package.json                       â”‚ â”‚
â”‚  â”‚  - Direct fetch() calls to API                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚ HTTP/JSON
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     API Gateway Layer                        â”‚
â”‚                      (Port 3000)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Request Router                                        â”‚ â”‚
â”‚  â”‚  - CORS handling                                       â”‚ â”‚
â”‚  â”‚  - Content negotiation                                 â”‚ â”‚
â”‚  â”‚  - Error normalization                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Command Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Schema     â”‚  â”‚   Content    â”‚  â”‚    Asset     â”‚      â”‚
â”‚  â”‚   Commands   â”‚  â”‚   Commands   â”‚  â”‚   Commands   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚                  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Event Store                             â”‚
â”‚                   (lib/store/EventStore)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Directory Structure

```
/
â”œâ”€â”€ lib/                          # ğŸ“¦ LIBRARY CODE
â”‚   â”œâ”€â”€ router/                   # Core routing primitives
â”‚   â”‚   â”œâ”€â”€ index.ts             # Router class & route registration
â”‚   â”‚   â”œâ”€â”€ types.ts             # Route, Handler, Middleware types
â”‚   â”‚   â””â”€â”€ response.ts          # Response helpers (json, error, etc)
â”‚   â””â”€â”€ adapters/                # Runtime adapters
â”‚       â””â”€â”€ bun.ts               # Bun HTTP server adapter
â”‚       # cloudflare.ts          # Cloudflare Workers adapter (future)
â”‚       # node.ts                # Node.js adapter (future)
â”‚
â”œâ”€â”€ src/                          # ğŸ  USER IMPLEMENTATION
â”‚   â”œâ”€â”€ routes.ts                # HTTP route definitions (Laravel-style)
â”‚   â”œâ”€â”€ server.ts                # HTTP server entry point
â”‚   # cli.ts                     # CLI entry point (Phase 4)
â”‚   # commands.ts                # CLI command registry (Phase 4)
â”‚   â”‚
â”‚   â”œâ”€â”€ handlers/                # HTTP route handlers
â”‚   â”‚   â”œâ”€â”€ home.ts              # GET / (Phase 2)
â”‚   â”‚   â”œâ”€â”€ posts/               # Blog post handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /posts
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /posts/:slug
â”‚   â”‚   â”‚   â”œâ”€â”€ create.ts        # POST /posts
â”‚   â”‚   â”‚   â”œâ”€â”€ update.ts        # PUT /posts/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /posts/:id
â”‚   â”‚   â”œâ”€â”€ authors/             # Author handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /authors
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /authors/:slug
â”‚   â”‚   â”‚   â”œâ”€â”€ create.ts        # POST /authors
â”‚   â”‚   â”‚   â”œâ”€â”€ update.ts        # PUT /authors/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /authors/:id
â”‚   â”‚   â”œâ”€â”€ categories/          # Category handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /categories
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /categories/:slug
â”‚   â”‚   â”‚   â””â”€â”€ posts.ts         # GET /categories/:slug/posts
â”‚   â”‚   â”œâ”€â”€ media/               # Media/asset handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.ts        # POST /media
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /media/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /media/:id
â”‚   â”‚   â””â”€â”€ schemas/             # Schema management (reference)
â”‚   â”‚       â”œâ”€â”€ list.ts          # GET /api/schemas
â”‚   â”‚       â”œâ”€â”€ show.ts          # GET /api/schemas/:id
â”‚   â”‚       â”œâ”€â”€ create.ts        # POST /api/schemas
â”‚   â”‚       â”œâ”€â”€ update.ts        # PUT /api/schemas/:id
â”‚   â”‚       â””â”€â”€ destroy.ts       # DELETE /api/schemas/:id
â”‚   â”‚
â”‚   # commands/                  # CLI command handlers (Phase 4)
â”‚   #   â”œâ”€â”€ posts/               # Post CLI commands
â”‚   #   â”‚   â”œâ”€â”€ list.ts          # cms posts:list
â”‚   #   â”‚   â””â”€â”€ create.ts        # cms posts:create
â”‚   #   â”œâ”€â”€ authors/             # Author CLI commands
â”‚   #   â”‚   â”œâ”€â”€ list.ts          # cms authors:list
â”‚   #   â”‚   â””â”€â”€ create.ts        # cms authors:create
â”‚   #   â””â”€â”€ events/              # Event management commands
â”‚   #       â”œâ”€â”€ list.ts          # cms events:list
â”‚   #       â””â”€â”€ replay.ts        # cms events:replay
â”‚   â”‚
â”‚   â”œâ”€â”€ middleware/              # Custom middleware (HTTP)
â”‚   â”‚   â”œâ”€â”€ cors.ts             # CORS configuration
â”‚   â”‚   â”œâ”€â”€ auth.ts             # Authentication (future)
â”‚   â”‚   â””â”€â”€ logging.ts          # Request logging
â”‚   â”‚
â”‚   â””â”€â”€ ui/                      # View layer (framework-agnostic)
â”‚       â”œâ”€â”€ components/          # UI components
â”‚       â”‚   â””â”€â”€ Homepage.tsx     # Homepage component (Phase 3)
â”‚       â”‚   # ApiProvider.tsx    # API context (reference pattern)
â”‚       â”‚   # ...                # Additional components (user implementation)
â”‚       â””â”€â”€ main.tsx             # Application entry (React/Vue)
â”‚
â”œâ”€â”€ shared/                       # Shared type definitions
â”‚   â””â”€â”€ types/
â”‚       â”œâ”€â”€ api.ts               # API request/response types
â”‚       â””â”€â”€ index.ts             # Exports
â”‚
â”œâ”€â”€ package.json                  # Top-level dependencies (server + UI)
â”œâ”€â”€ tsconfig.json                 # TypeScript configuration
â””â”€â”€ vite.config.ts                # Vite configuration for UI dev server
```

## Backend Routing Implementation

### 1. Core Router Types (lib/router/types.ts)

Framework-agnostic types that work with standard Request/Response objects:

```typescript
// lib/router/types.ts
export interface RouteContext {
  params: Record<string, string>;
  query: URLSearchParams;
  [key: string]: unknown; // Extensible for middleware data
}

export type RouteHandler = (
  request: Request,
  context: RouteContext
) => Promise<Response> | Response;

export type Middleware = (
  request: Request,
  context: RouteContext,
  next: () => Promise<Response>
) => Promise<Response>;

// Route definition supports multiple patterns:
// 1. Direct handler function
// 2. Dynamic import (lazy-loaded handler)
// 3. Object with handler and middleware
export type RouteDefinition = 
  | RouteHandler
  | Promise<{ default: RouteHandler }>  // Dynamic import support
  | {
      handler: RouteHandler | Promise<{ default: RouteHandler }>;
      middleware?: Middleware[];
    };

interface Route {
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  path: string;
  handler: RouteHandler | Promise<{ default: RouteHandler }>;
  middleware: Middleware[];
}
```

### 2. Router Class (lib/router/index.ts)

Laravel-style route registration:

```typescript
// lib/router/index.ts
import type { RouteDefinition, RouteHandler, Middleware, RouteContext } from './types';

export class Router {
  private routes: Route[] = [];
  private globalMiddleware: Middleware[] = [];

  // Global middleware (applied to all routes)
  use(middleware: Middleware): void {
    this.globalMiddleware.push(middleware);
  }

  // Laravel-style route registration
  get(path: string, definition: RouteDefinition): void {
    this.addRoute('GET', path, definition);
  }

  post(path: string, definition: RouteDefinition): void {
    this.addRoute('POST', path, definition);
  }

  put(path: string, definition: RouteDefinition): void {
    this.addRoute('PUT', path, definition);
  }

  patch(path: string, definition: RouteDefinition): void {
    this.addRoute('PATCH', path, definition);
  }

  delete(path: string, definition: RouteDefinition): void {
    this.addRoute('DELETE', path, definition);
  }

  private addRoute(method: string, path: string, definition: RouteDefinition): void {
    // Normalize definition to { handler, middleware }
    let handler: RouteHandler | Promise<{ default: RouteHandler }>;
    let middleware: Middleware[] = [];

    if (typeof definition === 'function') {
      // Direct handler function
      handler = definition;
    } else if (definition instanceof Promise) {
      // Dynamic import
      handler = definition;
    } else {
      // Object with handler and middleware
      handler = definition.handler;
      middleware = definition.middleware || [];
    }

    this.routes.push({
      method,
      path,
      handler,
      middleware,
    });
  }

  async handle(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const match = this.matchRoute(request.method, url.pathname);

    if (!match) {
      return new Response('Not Found', { status: 404 });
    }

    const context: RouteContext = {
      params: match.params,
      query: url.searchParams,
    };

    // Resolve handler if it's a dynamic import
    const handler = await this.resolveHandler(match.route.handler);

    // Build middleware chain: global â†’ route-specific â†’ handler
    const middlewareChain = [
      ...this.globalMiddleware,
      ...match.route.middleware,
    ];

    // Execute middleware chain
    return this.executeMiddleware(middlewareChain, request, context, handler);
  }

  private async resolveHandler(
    handler: RouteHandler | Promise<{ default: RouteHandler }>
  ): Promise<RouteHandler> {
    if (handler instanceof Promise) {
      const module = await handler;
      return module.default;
    }
    return handler;
  }

  private async executeMiddleware(
    middleware: Middleware[],
    request: Request,
    context: RouteContext,
    handler: RouteHandler
  ): Promise<Response> {
    let index = 0;

    const next = async (): Promise<Response> => {
      if (index < middleware.length) {
        const mw = middleware[index++];
        return mw(request, context, next);
      }
      return handler(request, context);
    };

    return next();
  }

  private matchRoute(method: string, pathname: string): RouteMatch | null {
    // Pattern matching implementation (supports :param syntax)
    for (const route of this.routes) {
      if (route.method !== method) continue;
      
      const match = this.matchPath(route.path, pathname);
      if (match) {
        return { route, params: match };
      }
    }
    return null;
  }

  private matchPath(pattern: string, pathname: string): Record<string, string> | null {
    const patternParts = pattern.split('/').filter(Boolean);
    const pathParts = pathname.split('/').filter(Boolean);

    if (patternParts.length !== pathParts.length) return null;

    const params: Record<string, string> = {};

    for (let i = 0; i < patternParts.length; i++) {
      const patternPart = patternParts[i];
      const pathPart = pathParts[i];

      if (patternPart.startsWith(':')) {
        // Dynamic segment
        params[patternPart.slice(1)] = pathPart;
      } else if (patternPart !== pathPart) {
        // Static segment mismatch
        return null;
      }
    }

    return params;
  }
}

interface RouteMatch {
  route: Route;
  params: Record<string, string>;
}
```

### 3. Response Helpers (lib/router/response.ts)

```typescript
// lib/router/response.ts
export const json = (data: unknown, status = 200): Response => {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json' }
  });
};

export const error = (message: string, status = 400): Response => {
  return json({ 
    error: message,
    code: getErrorCode(status),
    meta: { timestamp: new Date().toISOString() }
  }, status);
};

export const notFound = (resource = 'Resource'): Response => {
  return error(`${resource} not found`, 404);
};

function getErrorCode(status: number): string {
  const codes: Record<number, string> = {
    400: 'BAD_REQUEST',
    401: 'UNAUTHORIZED',
    403: 'FORBIDDEN',
    404: 'NOT_FOUND',
    500: 'INTERNAL_ERROR',
  };
  return codes[status] || 'ERROR';
}
```

## Route Definition (Laravel-Style)

### Routes File (src/routes.ts)

Routes can be defined using static imports or dynamic imports (lazy-loaded). Both patterns work seamlessly.

**Example for Phase 2 (Minimal Implementation):**

```typescript
// src/routes.ts
import { Router } from '../lib/router';
import { corsMiddleware } from './middleware/cors';
import { loggingMiddleware } from './middleware/logging';

export function registerRoutes(router: Router) {
  // Global middleware
  router.use(corsMiddleware);
  router.use(loggingMiddleware);

  // Homepage route (implement this in Phase 2)
  router.get('/', import('./handlers/home'));
}
```

**Full Example (Reference for Future Implementation):**

```typescript
// src/routes.ts - Full example showing multiple routes
import { Router } from '../lib/router';
import { corsMiddleware } from './middleware/cors';
import { loggingMiddleware } from './middleware/logging';

export function registerRoutes(router: Router) {
  // Global middleware
  router.use(corsMiddleware);
  router.use(loggingMiddleware);

  // Homepage route
  router.get('/', import('./handlers/home'));

  // Blog post routes - dynamic imports (for reference)
  router.get('/posts', import('./handlers/posts/list'));
  router.get('/posts/:slug', import('./handlers/posts/show'));
  router.post('/posts', import('./handlers/posts/create'));
  router.put('/posts/:id', import('./handlers/posts/update'));
  router.delete('/posts/:id', import('./handlers/posts/destroy'));

  // Author routes (for reference)
  router.get('/authors', import('./handlers/authors/list'));
  router.get('/authors/:slug', import('./handlers/authors/show'));
  router.post('/authors', import('./handlers/authors/create'));
  router.put('/authors/:id', import('./handlers/authors/update'));
  router.delete('/authors/:id', import('./handlers/authors/destroy'));

  // Category routes (for reference)
  router.get('/categories', import('./handlers/categories/list'));
  router.get('/categories/:slug', import('./handlers/categories/show'));
  router.get('/categories/:slug/posts', import('./handlers/categories/posts'));

  // Asset/media routes (for reference)
  router.post('/media', import('./handlers/media/upload'));
  router.get('/media/:id', import('./handlers/media/show'));
  router.delete('/media/:id', import('./handlers/media/destroy'));

  // API routes for CMS admin (for reference)
  router.get('/api/schemas', import('./handlers/schemas/list'));
  router.post('/api/schemas', import('./handlers/schemas/create'));
  router.get('/api/schemas/:id', import('./handlers/schemas/show'));
  router.put('/api/schemas/:id', import('./handlers/schemas/update'));
  router.delete('/api/schemas/:id', import('./handlers/schemas/destroy'));
}
```

### Benefits of Dynamic Imports

**1. Lazy Loading**
- Handlers only loaded when route is first accessed
- Faster server startup time
- Reduced memory footprint

**2. Tree-shaking**
- Unused handlers are completely removed from bundle
- Bundler can optimize better with explicit import paths

**3. Flexibility**
- Mix static and dynamic imports based on needs
- Critical routes (health checks) can use static imports
- Less-used routes can use dynamic imports

**4. Frontend Optimization**
- When bundling for frontend, Vite automatically code-splits dynamic imports
- Each handler becomes a separate chunk
- Loaded on-demand in the browser

### Handler Module Structure

Handlers export a default function or object with handler + middleware.

**Phase 2 Implementation (Homepage Handler):**

```typescript
// src/handlers/home.ts
import { json } from '../../lib/router/response';
import type { RouteHandler } from '../../lib/router/types';

export default (async (request, context) => {
  // TODO: Get homepage data from event store projection
  const data = {
    title: 'Welcome to My Blog',
    featured: [],
    recent: [],
  };
  
  return json({
    data,
    meta: { timestamp: new Date().toISOString() }
  });
}) as RouteHandler;
```

**Note**: Handler file organization is flexible. You could use `handlers/home.ts`, `handlers/home/index.ts`, or any structure that makes sense for your project.

**Reference Examples (For Future Implementation):**

```typescript
// src/handlers/posts/list.ts
import { json } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

// Simple handler export
export default (async (request, context) => {
  // TODO: Get posts from event store projection
  const posts = [];
  
  return json({
    data: posts,
    meta: {
      total: posts.length,
      timestamp: new Date().toISOString(),
    }
  });
}) as RouteHandler;
```

```typescript
// src/handlers/posts/show.ts
import { json, notFound } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

export default (async (request, context) => {
  const { slug } = context.params;
  
  // TODO: Get post by slug from projection
  const post = null; // await getPostBySlug(slug);
  
  if (!post) {
    return notFound('Post');
  }
  
  return json({
    data: post,
    meta: { timestamp: new Date().toISOString() }
  });
}) as RouteHandler;
```

```typescript
// src/handlers/posts/create.ts
import { json, error } from '../../../lib/router/response';
import type { RouteDefinition, RouteHandler } from '../../../lib/router/types';
import { validateJson } from '../../middleware/validation';

// Handler with middleware
const handler: RouteHandler = async (request, context) => {
  const body = await request.json();
  
  // TODO: Validate and emit PostCreated event
  
  return json({
    data: { id: 'post-123', slug: 'my-first-post', ...body },
    meta: { timestamp: new Date().toISOString() }
  }, 201);
};

// Export as object with middleware
export default {
  handler,
  middleware: [validateJson],
} as RouteDefinition;
```

```typescript
// src/handlers/authors/show.ts
import { json, notFound } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

export default (async (request, context) => {
  const { slug } = context.params;
  
  // TODO: Get author by slug from projection
  const author = null; // await getAuthorBySlug(slug);
  
  if (!author) {
    return notFound('Author');
  }
  
  // TODO: Get author's posts
  const posts = []; // await getPostsByAuthor(author.id);
  
  return json({
    data: {
      ...author,
      posts,
    },
    meta: { timestamp: new Date().toISOString() }
  });
}) as RouteHandler;
```

### Usage Patterns Comparison

```typescript
// Pattern 1: Static import
import listPosts from './handlers/posts/list';
router.get('/api/posts', listPosts);

// Pattern 2: Dynamic import (recommended)
router.get('/api/posts', import('./handlers/posts/list'));

// Pattern 3: Dynamic import with middleware
router.post('/api/posts', import('./handlers/posts/create'));
// The handler module exports { handler, middleware } - works seamlessly

// Pattern 4: Inline handler (for simple cases)
router.get('/health', async (request, context) => {
  return new Response('OK', { status: 200 });
});
```

**Recommendation**: Use dynamic imports (`import()`) by default for better optimization. Use static imports only for critical routes that need to respond immediately on first request (e.g., health checks).

### Supported Route Patterns

```typescript
// Exact match
/posts
/authors

// Single param (slug or ID)
/posts/:slug
/authors/:slug

// Multiple params
/categories/:categorySlug/posts/:postSlug

// Nested resources
/authors/:authorId/posts

// Query strings (handled via context.query)
/posts?page=1&limit=20&category=tech

// API routes (for admin/CMS management)
/api/schemas
/api/schemas/:id
```

### Example API Responses

**Homepage:**
```json
GET /

{
  "data": {
    "title": "Welcome to My Blog",
    "featured": [],
    "recent": []
  },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

**List Blog Posts:**
```json
GET /posts?page=1&limit=10

{
  "data": [
    {
      "id": "post-123",
      "slug": "getting-started-with-cms",
      "title": "Getting Started with CMS",
      "excerpt": "Learn how to build content websites...",
      "author": { "id": "author-1", "name": "Jane Doe" },
      "publishedAt": "2025-12-01T10:00:00Z"
    }
  ],
  "meta": {
    "total": 42,
    "page": 1,
    "perPage": 10,
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

**Show Author Profile:**
```json
GET /authors/jane-doe

{
  "data": {
    "id": "author-1",
    "slug": "jane-doe",
    "name": "Jane Doe",
    "bio": "Content strategist and writer...",
    "posts": [
      {
        "id": "post-123",
        "slug": "getting-started-with-cms",
        "title": "Getting Started with CMS"
      }
    ]
  },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

### Dynamic Import Performance

**Backend (Bun/Node)**
- Handler loaded once on first request
- Cached for subsequent requests
- Minimal overhead (~1-5ms first hit)
- No overhead after first load

**Frontend (Vite)**
- Handler becomes separate chunk
- Loaded only when route is navigated to
- Significantly reduces initial bundle size
- Perfect for large applications with many routes

**Optional Grouping**: For large applications, you can optionally organize routes into groups by creating helper functions or separate files, but it's not required. The pattern supports both approaches.

## Request/Response Format

### Standard Request Body

All POST/PUT requests accept JSON:

```typescript
// shared/types/api.ts
export interface CreateSchemaRequest {
  name: string;
  fields: FieldDefinition[];
}

export interface CreateContentRequest {
  schemaId: string;
  data: Record<string, unknown>;
}

export interface UpdateContentRequest {
  data: Record<string, unknown>;
}
```

### Standard Response Format

Success responses:

```typescript
// Single resource
{
  "data": { ... },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}

// Collection
{
  "data": [ ... ],
  "meta": {
    "total": 42,
    "page": 1,
    "perPage": 20,
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

Error responses:

```typescript
{
  "error": "Resource not found",
  "code": "NOT_FOUND",
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

## Middleware

### CORS Middleware (src/middleware/cors.ts)

Backend must support frontend development on separate port:

```typescript
// src/middleware/cors.ts
import type { Middleware } from '../../lib/router/types';

const allowedOrigins = [
  'http://localhost:5173',  // Vite dev server (default)
  'http://localhost:3000',  // Same-origin
];

export const corsMiddleware: Middleware = async (request, context, next) => {
  const origin = request.headers.get('origin');
  const response = await next();
  
  if (origin && allowedOrigins.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  }
  
  return response;
};
```

### Logging Middleware (src/middleware/logging.ts)

```typescript
// src/middleware/logging.ts
import type { Middleware } from '../../lib/router/types';

export const loggingMiddleware: Middleware = async (request, context, next) => {
  const start = Date.now();
  const { method, url } = request;
  
  const response = await next();
  
  const duration = Date.now() - start;
  console.log(`${method} ${url} ${response.status} ${duration}ms`);
  
  return response;
};
```

## Server Entry Point

### Main Server File (src/server.ts)

```typescript
// src/server.ts
import { Router } from '../lib/router';
import { createBunServer } from '../lib/adapters/bun';
import { registerRoutes } from './routes';

const router = new Router();
registerRoutes(router);

const server = createBunServer(router, 3000);

console.log(`Server running at http://localhost:${server.port}`);
```

## Runtime Adapters

### Bun Adapter (lib/adapters/bun.ts)

```typescript
import type { Router } from '../router';

export const createBunServer = (router: Router, port = 3000) => {
  return Bun.serve({
    port,
    fetch: (request) => router.handle(request),
  });
};
```

### Future Adapters

**Cloudflare Workers** (future)
- Will enable deployment to Cloudflare's edge network
- Same Router interface, different adapter
- Priority: After local development story is solid

**Node.js** (future)
- Optional adapter for Node.js environments
- Lower priority - Bun is primary runtime

## CLI Architecture (Future - Phase 4)

**Note**: CLI implementation is deferred to Phase 4. Focus is currently on getting the HTTP routing and local development experience right first.

### Overview

The CLI will follow the same pattern as HTTP routing, providing a consistent developer experience:

```typescript
// src/cli.ts (Phase 4 - future implementation)
import { CLI } from '../lib/cli';
import { registerCommands } from './commands';

const cli = new CLI();
registerCommands(cli);

cli.run(process.argv);
```

### Command Registration Pattern

Similar to Laravel's routing, but for CLI commands:

```typescript
// src/commands.ts (Phase 4 - future)
import { CLI } from '../lib/cli';

// Command handlers
import listPosts from './commands/posts/list';
import createPost from './commands/posts/create';
import listAuthors from './commands/authors/list';
import listEvents from './commands/events/list';
import replayEvents from './commands/events/replay';

export function registerCommands(cli: CLI) {
  // Post commands
  cli.command('posts:list', listPosts)
     .description('List all blog posts');
  
  cli.command('posts:create', createPost)
     .description('Create a new blog post');
  
  // Author commands
  cli.command('authors:list', listAuthors)
     .description('List all authors');
  
  // Event commands
  cli.command('events:list', listEvents)
     .description('List all events from the event store');
  
  cli.command('events:replay', replayEvents)
     .description('Replay events to rebuild projections');
}
```

### Command Handler Structure

Command handlers would mirror HTTP handlers but work with CLI context:

```typescript
// src/commands/posts/list.ts (Phase 4 - future)
import type { CommandHandler } from '../../lib/cli/types';

export default (async (args, context) => {
  // Access event store
  const posts = []; // TODO: Get from event store projection
  
  // Output to console
  console.table(posts.map(p => ({
    id: p.id,
    title: p.title,
    author: p.author.name,
    published: p.publishedAt
  })));
  
  return 0; // Exit code
}) as CommandHandler;
```

### CLI vs HTTP Routing Comparison

| Aspect | HTTP Routing | CLI Routing |
|--------|-------------|-------------|
| **Entry Point** | `src/server.ts` | `src/cli.ts` |
| **Route File** | `src/routes.ts` | `src/commands.ts` |
| **Handlers** | `src/handlers/*` | `src/commands/*` |
| **Registration** | `router.get(path, handler)` | `cli.command(name, handler)` |
| **Context** | `{ params, query }` | `{ args, flags }` |
| **Output** | `Response` object | Exit code + stdout |
| **Middleware** | CORS, auth, logging | Validation, auth, logging |

### Benefits of This Pattern

1. **Consistent Interface**: Same pattern for web and CLI
2. **Shared Logic**: Handlers can use same commands/event store
3. **Testable**: CLI commands can be tested like HTTP routes
4. **Discoverable**: All commands in one file (`src/commands.ts`)
5. **Extensible**: Easy to add new commands without touching core

### Example Usage

```bash
# List posts
bun run src/cli.ts posts:list

# Create post interactively
bun run src/cli.ts posts:create --title "My First Post" --author jane-doe

# Replay events for specific date
bun run src/cli.ts events:replay --date 2025-12-08

# List posts by author
bun run src/cli.ts posts:list --author jane-doe
```

### Package.json Scripts (Phase 4 - future)

```json
{
  "scripts": {
    "dev": "vite",
    "server": "bun run src/server.ts",
    "cms": "bun run src/cli.ts",
    "dev:all": "concurrently \"bun run server\" \"bun run dev\""
  }
}
```

Then users can run: `bun run cms posts:list`

## Frontend Integration

### API Provider Pattern

The UI layer includes an API provider component that manages connection configuration:

**Note**: This is a reference pattern. Phase 3 will implement a simple homepage without ApiProvider. Users can implement this pattern based on their needs.

```typescript
// src/ui/components/ApiProvider.tsx (Reference - not implemented in Phase 3)
import { createContext, useContext, ReactNode } from 'react';

const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000';

interface ApiContextValue {
  baseUrl: string;
  getSchemas: () => Promise<Schema[]>;
  createContent: (request: CreateContentRequest) => Promise<Content>;
  // ... more methods
}

const ApiContext = createContext<ApiContextValue | null>(null);

export function ApiProvider({ 
  children, 
  baseUrl = API_BASE 
}: { 
  children: ReactNode; 
  baseUrl?: string;
}) {
  const api: ApiContextValue = {
    baseUrl,
    
    async getSchemas() {
      const response = await fetch(`${baseUrl}/api/schemas`);
      const { data } = await response.json();
      return data;
    },
    
    async createContent(request: CreateContentRequest) {
      const response = await fetch(`${baseUrl}/api/content`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });
      const { data } = await response.json();
      return data;
    },
    
    // ... more methods
  };
  
  return <ApiContext.Provider value={api}>{children}</ApiContext.Provider>;
}

export function useApi() {
  const context = useContext(ApiContext);
  if (!context) {
    throw new Error('useApi must be used within ApiProvider');
  }
  return context;
}
```

### Phase 3 Implementation (Simple Homepage)

```typescript
// src/ui/main.tsx
import { createRoot } from 'react-dom/client';
import { Homepage } from './components/Homepage';

createRoot(document.getElementById('root')!).render(<Homepage />);
```

```typescript
// src/ui/components/Homepage.tsx
import { useEffect, useState } from 'react';

const API_BASE = 'http://localhost:3000';

export function Homepage() {
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`${API_BASE}/`)
      .then(res => res.json())
      .then(result => {
        setData(result.data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      <h1>{data.title}</h1>
      <p>Homepage rendering successfully!</p>
      {/* Users can extend this with their own UI */}
    </div>
  );
}
```

### Vue Provider Alternative

For Vue projects, a similar composable pattern:

```typescript
// src/ui/components/ApiProvider.vue (or use provide/inject)
import { provide, inject } from 'vue';

const ApiSymbol = Symbol('api');

export function provideApi(baseUrl = 'http://localhost:3000') {
  provide(ApiSymbol, {
    baseUrl,
    async getSchemas() { /* ... */ },
    async createContent() { /* ... */ },
  });
}

export function useApi() {
  const api = inject(ApiSymbol);
  if (!api) throw new Error('useApi requires provideApi');
  return api;
}
```

### Environment Configuration

```bash
# .env.development (root level)
VITE_API_URL=http://localhost:3000

# .env.production (root level)
VITE_API_URL=https://api.yourdomain.com
```

## Development Workflow

### Build Tools

**Backend (Bun)**
- Use Bun for running the HTTP server: `bun run src/server.ts`
- Fast startup, native TypeScript support
- No build step needed for development

**Frontend (Vite)**
- Use Vite for UI bundling and dev server
- Optimized code splitting and lazy loading
- Best-in-class HMR (Hot Module Replacement)
- Production builds automatically optimize bundle size

**Why This Combination?**
- Bun excels at server-side TypeScript execution
- Vite excels at frontend bundling and optimization
- Both work together seamlessly via CORS

### Running Backend Only

```bash
cd /home/ubuntu/sites/ai-cms
bun run src/server.ts
# Server runs on http://localhost:3000
```

### Running Full Stack (Backend + UI)

```bash
# Terminal 1: Backend
bun run src/server.ts

# Terminal 2: UI (Vite dev server)
bun run dev
# UI runs on http://localhost:5173, proxies API to :3000
```

### Package Scripts (package.json)

```json
{
  "scripts": {
    "dev": "vite",
    "server": "bun run src/server.ts",
    "dev:all": "concurrently \"bun run server\" \"bun run dev\"",
    "build": "vite build",
    "build:server": "bun build src/server.ts --outdir dist --target bun",
    "preview": "vite preview"
  }
}
```

## Testing Strategy

### Handler Unit Tests

Test individual handlers in isolation:

```typescript
// src/handlers/posts/__tests__/list.test.ts
import { describe, it, expect } from 'bun:test';
import listPosts from '../list';

describe('listPosts handler', () => {
  it('returns empty array when no posts exist', async () => {
    const request = new Request('http://localhost:3000/posts');
    const context = { params: {}, query: new URLSearchParams() };
    
    const response = await listPosts(request, context);
    expect(response.status).toBe(200);
    
    const { data } = await response.json();
    expect(Array.isArray(data)).toBe(true);
  });

  it('filters posts by query params', async () => {
    const request = new Request('http://localhost:3000/posts?category=tech');
    const context = { 
      params: {}, 
      query: new URLSearchParams('category=tech') 
    };
    
    const response = await listPosts(request, context);
    const { data } = await response.json();
    
    // TODO: verify filtering works
  });
});
```

### Integration Tests

Test complete router with all routes:

```typescript
// src/__tests__/routes.test.ts
import { Router } from '../lib/router';
import { registerRoutes } from './routes';

describe('API Routes', () => {
  const router = new Router();
  registerRoutes(router);

  it('GET / returns 200', async () => {
    const request = new Request('http://localhost:3000/');
    const response = await router.handle(request);
    expect(response.status).toBe(200);
  });

  it('GET /posts/:slug returns post', async () => {
    const request = new Request('http://localhost:3000/posts/my-first-post');
    const response = await router.handle(request);
    expect(response.status).toBe(200);
    
    const { data } = await response.json();
    expect(data.slug).toBe('my-first-post');
  });

  it('unknown routes return 404', async () => {
    const request = new Request('http://localhost:3000/unknown');
    const response = await router.handle(request);
    expect(response.status).toBe(404);
  });
});
```

### Running Tests

```bash
bun test src/
```

## Implementation Phases

### Phase 1: Core Router (Foundation) - **PRIORITY**
- [ ] Implement `lib/router/index.ts` with pattern matching
- [ ] Implement `lib/router/types.ts` with dynamic import support
- [ ] Add `lib/router/response.ts` helpers (json, error, notFound)
- [ ] Create Bun adapter (`lib/adapters/bun.ts`)
- [ ] Write router unit tests

### Phase 2: Basic API Routes - **PRIORITY**
- [ ] Set up `src/server.ts` entry point
- [ ] Create `src/routes.ts` with homepage route
- [ ] Implement homepage handler (`handlers/home.ts`)
- [ ] Add CORS middleware
- [ ] Add logging middleware
- [ ] Test with curl/browser

**Note**: Phase 2 focuses on minimal routing setup. Additional routes (posts, authors, etc.) shown in examples are for reference - users will implement as needed. Handler file organization is flexible (e.g., `home.ts`, `home/index.ts`, etc.).

### Phase 3: Frontend Integration
- [ ] Set up Vite configuration
- [ ] Create `src/ui/` structure
- [ ] Build simple homepage component
- [ ] Fetch and display data from API
- [ ] Test end-to-end flow

**Note**: Phase 3 focuses on a minimal homepage example. ApiProvider pattern and full CRUD UI are left for users to implement based on their needs.

### Phase 4: CLI & Production Deployment (Future)
- [ ] Design CLI architecture (`lib/cli/`)
- [ ] Implement command registration system
- [ ] Create `src/cli.ts` entry point
- [ ] Create `src/commands.ts` command registry
- [ ] Build example commands (posts:list, events:replay)
- [ ] Implement Cloudflare Workers adapter
- [ ] Add deployment configuration
- [ ] Test production build
- [ ] Document deployment process

## Success Criteria

1. **Backend runs independently** without any frontend code
2. **Bun server starts quickly** (<100ms) with hot reload support
3. **Zero framework-specific code** in `lib/` directory
4. **Dynamic imports work seamlessly** for lazy-loaded handlers
5. **All API routes follow consistent patterns** (REST conventions)
6. **Full TypeScript type safety** between client and server
7. **Local development is smooth** with CORS and hot reload
8. **Routes are easy to add/modify** (Laravel-style simplicity)

**Deferred Success Criteria** (Phase 4):
- CLI commands work with same patterns as HTTP routes
- Cloudflare Workers deployment
- Node.js adapter support
- OpenAPI spec generation

## Open Questions

1. ~~Should we use a routing library (e.g., Hono, itty-router) or build custom?~~ **Decision: Build custom with dynamic import support**
2. How do we handle file uploads (multipart/form-data)?
3. Should we add request validation middleware (e.g., Zod)?
4. What's the authentication strategy for protected routes?
5. Should we generate OpenAPI specs automatically? (future consideration)

## References

- Web Fetch API: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
- Bun HTTP Server: https://bun.sh/docs/api/http
- Dynamic Imports: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import
- Cloudflare Workers (future): https://developers.cloudflare.com/workers/

---

**Next Steps**: Begin Phase 1 implementation - build the core router with Bun adapter and test with basic routes.
