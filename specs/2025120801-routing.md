# Routing Architecture Specification

**Spec ID**: 2025120801  
**Created**: 2025-12-08  
**Status**: Draft  
**Phase**: Foundation

## Overview

This spec defines the routing architecture for Project Conduit, establishing clear separation between backend API routing and frontend UI code. The backend must be framework-agnostic and capable of running independently, while supporting multiple frontend frameworks (React, Vue, etc.).

The routing pattern established here applies to both HTTP API routes and CLI commands, providing a consistent interface for both web and command-line interactions.

## Design Principles

1. **Complete Separation**: Backend and frontend are independently deployable
2. **Framework Agnostic Backend**: Core API routing has zero frontend dependencies
3. **Standard Interfaces**: REST/JSON API following web standards
4. **Type Safety**: Full TypeScript support with shared type definitions
5. **Development Experience**: Simple local development with hot reload

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        View Layer                            â”‚
â”‚                   (src/ui/ - .tsx or .vue)                   â”‚
â”‚                      (Port 5173)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Framework-agnostic UI components                      â”‚ â”‚
â”‚  â”‚  - React (.tsx) or Vue (.vue) components               â”‚ â”‚
â”‚  â”‚  - Shares top-level package.json                       â”‚ â”‚
â”‚  â”‚  - Direct fetch() calls to API                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚ HTTP/JSON
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     API Gateway Layer                        â”‚
â”‚                      (Port 3000)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Request Router                                        â”‚ â”‚
â”‚  â”‚  - CORS handling                                       â”‚ â”‚
â”‚  â”‚  - Content negotiation                                 â”‚ â”‚
â”‚  â”‚  - Error normalization                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Command Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Schema     â”‚  â”‚   Content    â”‚  â”‚    Asset     â”‚      â”‚
â”‚  â”‚   Commands   â”‚  â”‚   Commands   â”‚  â”‚   Commands   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚                  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Event Store                             â”‚
â”‚                   (lib/store/EventStore)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Directory Structure

```
/
â”œâ”€â”€ lib/                          # ğŸ“¦ LIBRARY CODE
â”‚   â”œâ”€â”€ router/                   # Core routing primitives
â”‚   â”‚   â”œâ”€â”€ index.ts             # Router class & route registration
â”‚   â”‚   â”œâ”€â”€ types.ts             # Route, Handler, Middleware types
â”‚   â”‚   â”œâ”€â”€ response.ts          # Framework-agnostic response helpers
â”‚   â”‚   â”œâ”€â”€ react/               # React-specific utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ response.tsx    # React SSR helpers (ui function)
â”‚   â”‚   â”‚   â””â”€â”€ README.md       # React utilities documentation
â”‚   â”‚   â””â”€â”€ vue/                 # Vue-specific utilities (future)
â”‚   â”‚       â””â”€â”€ README.md       # Vue utilities documentation
â”‚   â””â”€â”€ adapters/                # Runtime adapters
â”‚       â””â”€â”€ bun.ts               # Bun HTTP server adapter
â”‚       # cloudflare.ts          # Cloudflare Workers adapter (future)
â”‚       # node.ts                # Node.js adapter (future)
â”‚
â”œâ”€â”€ src/                          # ğŸ  USER IMPLEMENTATION
â”‚   â”œâ”€â”€ routes.ts                # HTTP route definitions (Laravel-style)
â”‚   â”œâ”€â”€ server.ts                # HTTP server entry point
â”‚   # cli.ts                     # CLI entry point (Phase 4)
â”‚   # commands.ts                # CLI command registry (Phase 4)
â”‚   â”‚
â”‚   â”œâ”€â”€ handlers/                # HTTP route handlers
â”‚   â”‚   â”œâ”€â”€ home.tsx             # GET / (Phase 2) - SSR React homepage
â”‚   â”‚   â”œâ”€â”€ posts/               # Blog post handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /posts
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /posts/:slug
â”‚   â”‚   â”‚   â”œâ”€â”€ create.ts        # POST /posts
â”‚   â”‚   â”‚   â”œâ”€â”€ update.ts        # PUT /posts/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /posts/:id
â”‚   â”‚   â”œâ”€â”€ authors/             # Author handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /authors
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /authors/:slug
â”‚   â”‚   â”‚   â”œâ”€â”€ create.ts        # POST /authors
â”‚   â”‚   â”‚   â”œâ”€â”€ update.ts        # PUT /authors/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /authors/:id
â”‚   â”‚   â”œâ”€â”€ categories/          # Category handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ list.ts          # GET /categories
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /categories/:slug
â”‚   â”‚   â”‚   â””â”€â”€ posts.ts         # GET /categories/:slug/posts
â”‚   â”‚   â”œâ”€â”€ media/               # Media/asset handlers (reference)
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.ts        # POST /media
â”‚   â”‚   â”‚   â”œâ”€â”€ show.ts          # GET /media/:id
â”‚   â”‚   â”‚   â””â”€â”€ destroy.ts       # DELETE /media/:id
â”‚   â”‚   â””â”€â”€ schemas/             # Schema management (reference)
â”‚   â”‚       â”œâ”€â”€ list.ts          # GET /api/schemas
â”‚   â”‚       â”œâ”€â”€ show.ts          # GET /api/schemas/:id
â”‚   â”‚       â”œâ”€â”€ create.ts        # POST /api/schemas
â”‚   â”‚       â”œâ”€â”€ update.ts        # PUT /api/schemas/:id
â”‚   â”‚       â””â”€â”€ destroy.ts       # DELETE /api/schemas/:id
â”‚   â”‚
â”‚   # commands/                  # CLI command handlers (Phase 4)
â”‚   #   â”œâ”€â”€ posts/               # Post CLI commands
â”‚   #   â”‚   â”œâ”€â”€ list.ts          # cms posts:list
â”‚   #   â”‚   â””â”€â”€ create.ts        # cms posts:create
â”‚   #   â”œâ”€â”€ authors/             # Author CLI commands
â”‚   #   â”‚   â”œâ”€â”€ list.ts          # cms authors:list
â”‚   #   â”‚   â””â”€â”€ create.ts        # cms authors:create
â”‚   #   â””â”€â”€ events/              # Event management commands
â”‚   #       â”œâ”€â”€ list.ts          # cms events:list
â”‚   #       â””â”€â”€ replay.ts        # cms events:replay
â”‚   â”‚
â”‚   â”œâ”€â”€ middleware/              # Custom middleware (HTTP)
â”‚   â”‚   â”œâ”€â”€ cors.ts             # CORS configuration
â”‚   â”‚   â”œâ”€â”€ auth.ts             # Authentication (future)
â”‚   â”‚   â””â”€â”€ logging.ts          # Request logging
â”‚   â”‚
â”‚   â””â”€â”€ ui/                      # View layer (framework-agnostic)
â”‚       â”œâ”€â”€ components/          # UI components
â”‚       â”‚   â””â”€â”€ Homepage.tsx     # Homepage component (Phase 3)
â”‚       â”‚   # ApiProvider.tsx    # API context (reference pattern)
â”‚       â”‚   # ...                # Additional components (user implementation)
â”‚       â”œâ”€â”€ layouts/             # Layout components for SSR
â”‚       â”‚   â”œâ”€â”€ default.tsx      # Default HTML layout
â”‚       â”‚   â”œâ”€â”€ custom.tsx       # Example custom layout
â”‚       â”‚   â””â”€â”€ README.md        # Layout documentation
â”‚       â””â”€â”€ main.tsx             # Application entry (React/Vue)
â”‚
â”œâ”€â”€ shared/                       # Shared type definitions
â”‚   â””â”€â”€ types/
â”‚       â”œâ”€â”€ api.ts               # API request/response types
â”‚       â””â”€â”€ index.ts             # Exports
â”‚
â”œâ”€â”€ package.json                  # Top-level dependencies (server + UI)
â”œâ”€â”€ tsconfig.json                 # TypeScript configuration
â””â”€â”€ vite.config.ts                # Vite configuration for UI dev server
```

## Backend Routing Implementation

### 1. Core Router Types (lib/router/types.ts)

Framework-agnostic types that work with standard Request/Response objects:

```typescript
// lib/router/types.ts
export interface RouteContext {
  params: Record<string, string>;
  query: URLSearchParams;
  [key: string]: unknown; // Extensible for middleware data
}

export type RouteHandler = (
  request: Request,
  context: RouteContext
) => Promise<Response> | Response;

export type Middleware = (
  request: Request,
  context: RouteContext,
  next: () => Promise<Response>
) => Promise<Response>;

// Route definition supports multiple patterns:
// 1. Direct handler function
// 2. Dynamic import (lazy-loaded handler)
// 3. Object with handler and middleware
export type RouteDefinition = 
  | RouteHandler
  | Promise<{ default: RouteHandler }>  // Dynamic import support
  | {
      handler: RouteHandler | Promise<{ default: RouteHandler }>;
      middleware?: Middleware[];
    };

interface Route {
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  path: string;
  handler: RouteHandler | Promise<{ default: RouteHandler }>;
  middleware: Middleware[];
}
```

### 2. Router Class (lib/router/index.ts)

Laravel-style route registration:

```typescript
// lib/router/index.ts
import type { RouteDefinition, RouteHandler, Middleware, RouteContext } from './types';

export class Router {
  private routes: Route[] = [];
  private globalMiddleware: Middleware[] = [];

  // Global middleware (applied to all routes)
  use(middleware: Middleware): void {
    this.globalMiddleware.push(middleware);
  }

  // Laravel-style route registration
  get(path: string, definition: RouteDefinition): void {
    this.addRoute('GET', path, definition);
  }

  post(path: string, definition: RouteDefinition): void {
    this.addRoute('POST', path, definition);
  }

  put(path: string, definition: RouteDefinition): void {
    this.addRoute('PUT', path, definition);
  }

  patch(path: string, definition: RouteDefinition): void {
    this.addRoute('PATCH', path, definition);
  }

  delete(path: string, definition: RouteDefinition): void {
    this.addRoute('DELETE', path, definition);
  }

  private addRoute(method: string, path: string, definition: RouteDefinition): void {
    // Normalize definition to { handler, middleware }
    let handler: RouteHandler | Promise<{ default: RouteHandler }>;
    let middleware: Middleware[] = [];

    if (typeof definition === 'function') {
      // Direct handler function
      handler = definition;
    } else if (definition instanceof Promise) {
      // Dynamic import
      handler = definition;
    } else {
      // Object with handler and middleware
      handler = definition.handler;
      middleware = definition.middleware || [];
    }

    this.routes.push({
      method,
      path,
      handler,
      middleware,
    });
  }

  async handle(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const match = this.matchRoute(request.method, url.pathname);

    if (!match) {
      return new Response('Not Found', { status: 404 });
    }

    const context: RouteContext = {
      params: match.params,
      query: url.searchParams,
    };

    // Resolve handler if it's a dynamic import
    const handler = await this.resolveHandler(match.route.handler);

    // Build middleware chain: global â†’ route-specific â†’ handler
    const middlewareChain = [
      ...this.globalMiddleware,
      ...match.route.middleware,
    ];

    // Execute middleware chain
    return this.executeMiddleware(middlewareChain, request, context, handler);
  }

  private async resolveHandler(
    handler: RouteHandler | Promise<{ default: RouteHandler }>
  ): Promise<RouteHandler> {
    if (handler instanceof Promise) {
      const module = await handler;
      return module.default;
    }
    return handler;
  }

  private async executeMiddleware(
    middleware: Middleware[],
    request: Request,
    context: RouteContext,
    handler: RouteHandler
  ): Promise<Response> {
    let index = 0;

    const next = async (): Promise<Response> => {
      if (index < middleware.length) {
        const mw = middleware[index++];
        return mw(request, context, next);
      }
      return handler(request, context);
    };

    return next();
  }

  private matchRoute(method: string, pathname: string): RouteMatch | null {
    // Pattern matching implementation (supports :param syntax)
    for (const route of this.routes) {
      if (route.method !== method) continue;
      
      const match = this.matchPath(route.path, pathname);
      if (match) {
        return { route, params: match };
      }
    }
    return null;
  }

  private matchPath(pattern: string, pathname: string): Record<string, string> | null {
    const patternParts = pattern.split('/').filter(Boolean);
    const pathParts = pathname.split('/').filter(Boolean);

    if (patternParts.length !== pathParts.length) return null;

    const params: Record<string, string> = {};

    for (let i = 0; i < patternParts.length; i++) {
      const patternPart = patternParts[i];
      const pathPart = pathParts[i];

      if (patternPart.startsWith(':')) {
        // Dynamic segment
        params[patternPart.slice(1)] = pathPart;
      } else if (patternPart !== pathPart) {
        // Static segment mismatch
        return null;
      }
    }

    return params;
  }
}

interface RouteMatch {
  route: Route;
  params: Record<string, string>;
}
```

### 3. Response Helpers

#### Framework-Agnostic Helpers (lib/router/response.ts)

Standard response utilities that work with any framework:

```typescript
// lib/router/response.ts
export const json = (data: unknown, status = 200): Response => {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json' }
  });
};

export const error = (message: string, status = 400): Response => {
  return json({ 
    error: message,
    code: getErrorCode(status),
    meta: { timestamp: new Date().toISOString() }
  }, status);
};

export const notFound = (resource = 'Resource'): Response => {
  return error(`${resource} not found`, 404);
};

export const redirect = (url: string, status: 301 | 302 | 307 | 308 = 302): Response => {
  return new Response(null, {
    status,
    headers: { Location: url }
  });
};

function getErrorCode(status: number): string {
  const codes: Record<number, string> = {
    400: 'BAD_REQUEST',
    401: 'UNAUTHORIZED',
    403: 'FORBIDDEN',
    404: 'NOT_FOUND',
    500: 'INTERNAL_ERROR',
  };
  return codes[status] || 'ERROR';
}
```

#### React SSR Helpers (lib/router/react/response.tsx)

Server-side rendering utilities for React components with **react-helmet-async** integration:

```typescript
// lib/router/react/response.tsx
import { renderToString } from 'react-dom/server';
import { HelmetProvider } from 'react-helmet-async';
import type { ReactElement } from 'react';

export interface UiOptions {
  status?: number;
  rootId?: string;
  layout?: ReactElement;
}

/**
 * Server-side render a React component to HTML
 * 
 * Components use react-helmet-async to manage their own head elements.
 * A layout component receives the rendered component as children.
 * 
 * @example
 * ```ts
 * import { ui } from '../../lib/router/react/response';
 * import { Homepage } from '../ui/components/Homepage';
 * 
 * // Simple usage - uses default layout
 * export default async function handler(ctx: RequestContext) {
 *   return ui(<Homepage />);
 * }
 * 
 * // With custom layout
 * import { CustomLayout } from '../ui/layouts/custom';
 * 
 * export default async function handler(ctx: RequestContext) {
 *   return ui(<Homepage />, { layout: <CustomLayout /> });
 * }
 * ```
 */
export function ui(
  component: ReactElement,
  options: UiOptions = {}
): Promise<Response> {
  const {
    status = 200,
    rootId = 'root',
    layout,
  } = options;
  
  // Import default layout if not provided
  const layoutPromise = layout 
    ? Promise.resolve(layout)
    : import('../../src/ui/layouts/default').then(m => <m.DefaultLayout />);
  
  return layoutPromise.then(layoutComponent => {
    const helmetContext = {};
    
    // Clone layout and inject component as children
    const layoutWithChildren = {
      ...layoutComponent,
      props: {
        ...layoutComponent.props,
        children: component,
      },
    };
    
    // Render with HelmetProvider to extract head tags
    const html = renderToString(
      <HelmetProvider context={helmetContext}>
        {layoutWithChildren}
      </HelmetProvider>
    );
    
    // Extract helmet data
    const { helmet } = helmetContext as any;
    
    // Build complete HTML document
    const document = `<!DOCTYPE html>
<html ${helmet.htmlAttributes.toString()}>
<head>
  ${helmet.title.toString()}
  ${helmet.meta.toString()}
  ${helmet.link.toString()}
</head>
<body ${helmet.bodyAttributes.toString()}>
  <div id="${rootId}">${html}</div>
</body>
</html>`;

    return new Response(document, {
      status,
      headers: {
        'Content-Type': 'text/html; charset=utf-8',
      },
    });
  });
}
```

**Design Rationale:**

1. **Framework Separation**: Response helpers are organized by framework:
   - `lib/router/response.ts` - Framework-agnostic (JSON, errors, redirects)
   - `lib/router/react/response.tsx` - React-specific (SSR)
   - `lib/router/vue/` - Vue-specific (future)

2. **Component-Based Head Management**: Uses **react-helmet-async** to let components control their own metadata:
   - Components use `<Helmet>` to set title, meta tags, etc.
   - No manual head management in handler code
   - Better component encapsulation
   - Standard React pattern

3. **Layout System**: Automatic layout wrapping with customization:
   - Default layout loaded automatically from `src/ui/layouts/default.tsx`
   - Custom layouts supported via `layout` option
   - Layout receives component as `children` prop
   - Consistent HTML structure across all pages

4. **Extensibility**: The `ui()` function abstracts SSR complexity:
   - Automatic helmet data extraction and injection
   - Layout system built-in
   - Future-proof for streaming, hydration, etc.
   - Returns `Promise<Response>` (handlers don't need to await)

5. **Import Clarity**: Import path reveals intent:
   - `from '../../lib/router/response'` - Standard responses
   - `from '../../lib/router/react/response'` - React SSR

#### Vue SSR Helpers (lib/router/vue/ - Future)

Similar pattern for Vue:

```typescript
// lib/router/vue/response.ts (future)
import { renderToString } from '@vue/server-renderer';

export function ui(
  component: Component,
  options: UiOptions = {}
): Response {
  // Vue SSR implementation
}
```

## Route Definition (Laravel-Style)

### Routes File (src/routes.ts)

Routes can be defined using static imports or dynamic imports (lazy-loaded). Both patterns work seamlessly.

**Example for Phase 2 (Minimal Implementation):**

```typescript
// src/routes.ts
import { Router } from '../lib/router';
import { corsMiddleware } from './middleware/cors';
import { loggingMiddleware } from './middleware/logging';

export function registerRoutes(router: Router) {
  // Global middleware
  router.use(corsMiddleware);
  router.use(loggingMiddleware);

  // Serve static files from public directory
  router.static('public');

  // Homepage route (implement this in Phase 2)
  router.get('/', import('./handlers/home'));
}
```

**Full Example (Reference for Future Implementation):**

```typescript
// src/routes.ts - Full example showing multiple routes
import { Router } from '../lib/router';
import { corsMiddleware } from './middleware/cors';
import { loggingMiddleware } from './middleware/logging';

export function registerRoutes(router: Router) {
  // Global middleware
  router.use(corsMiddleware);
  router.use(loggingMiddleware);

  // Serve static files from public directory
  router.static('public');

  // Homepage route
  router.get('/', import('./handlers/home'));

  // Blog post routes - dynamic imports (for reference)
  router.get('/posts', import('./handlers/posts/list'));
  router.get('/posts/:slug', import('./handlers/posts/show'));
  router.post('/posts', import('./handlers/posts/create'));
  router.put('/posts/:id', import('./handlers/posts/update'));
  router.delete('/posts/:id', import('./handlers/posts/destroy'));

  // Author routes (for reference)
  router.get('/authors', import('./handlers/authors/list'));
  router.get('/authors/:slug', import('./handlers/authors/show'));
  router.post('/authors', import('./handlers/authors/create'));
  router.put('/authors/:id', import('./handlers/authors/update'));
  router.delete('/authors/:id', import('./handlers/authors/destroy'));

  // Category routes (for reference)
  router.get('/categories', import('./handlers/categories/list'));
  router.get('/categories/:slug', import('./handlers/categories/show'));
  router.get('/categories/:slug/posts', import('./handlers/categories/posts'));

  // Asset/media routes (for reference)
  router.post('/media', import('./handlers/media/upload'));
  router.get('/media/:id', import('./handlers/media/show'));
  router.delete('/media/:id', import('./handlers/media/destroy'));

  // API routes for CMS admin (for reference)
  router.get('/api/schemas', import('./handlers/schemas/list'));
  router.post('/api/schemas', import('./handlers/schemas/create'));
  router.get('/api/schemas/:id', import('./handlers/schemas/show'));
  router.put('/api/schemas/:id', import('./handlers/schemas/update'));
  router.delete('/api/schemas/:id', import('./handlers/schemas/destroy'));
}
```

### Benefits of Dynamic Imports

**1. Lazy Loading**
- Handlers only loaded when route is first accessed
- Faster server startup time
- Reduced memory footprint

**2. Tree-shaking**
- Unused handlers are completely removed from bundle
- Bundler can optimize better with explicit import paths

**3. Flexibility**
- Mix static and dynamic imports based on needs
- Critical routes (health checks) can use static imports
- Less-used routes can use dynamic imports

**4. Frontend Optimization**
- When bundling for frontend, Vite automatically code-splits dynamic imports
- Each handler becomes a separate chunk
- Loaded on-demand in the browser

### Handler Module Structure

Handlers export a default function or object with handler + middleware.

**Phase 2 Implementation (Homepage Handler with React SSR):**

```typescript
// src/handlers/home.tsx
import type { RequestContext } from '../../lib/router/types';
import { ui } from '../../lib/router/react/response';
import { Homepage } from '../ui/components/Homepage';

/**
 * Homepage handler
 * Server-side renders the React Homepage component
 * Uses default layout automatically
 */
export default function home(ctx: RequestContext): Promise<Response> {
  return ui(<Homepage />);
}
```

**Component with Head Management:**

```typescript
// src/ui/components/Homepage.tsx
import { Helmet } from 'react-helmet-async';

export function Homepage() {
  return (
    <>
      <Helmet>
        <title>Project Conduit</title>
        <meta name="description" content="Event-sourced CMS for LLM-native workflows" />
        <meta name="keywords" content="cms, event-sourcing, llm" />
        <link rel="icon" href="/favicon.ico" />
      </Helmet>
      <div className="homepage">
        <h1>Welcome to Project Conduit</h1>
        <p>Your content here...</p>
      </div>
    </>
  );
}
```

**With Custom Layout:**

```typescript
// src/handlers/example-custom-layout.tsx
import { ui } from '../../lib/router/react/response';
import { Homepage } from '../ui/components/Homepage';
import { CustomLayout } from '../ui/layouts/custom';

export default function handler(ctx: RequestContext): Promise<Response> {
  return ui(<Homepage />, { 
    layout: <CustomLayout /> 
  });
}
```

**API Endpoint (JSON Response):**

```typescript
// src/handlers/api/info.ts
import { json } from '../../lib/router/response';
import type { RequestContext } from '../../lib/router/types';

export default async function info(ctx: RequestContext): Promise<Response> {
  return json({
    name: 'Project Conduit',
    version: '0.1.0',
    description: 'Event-sourced CMS for LLM-native workflows',
  });
}
```

**Note**: Handler file organization is flexible. You could use `handlers/home.tsx`, `handlers/home/index.tsx`, or any structure that makes sense for your project. Use `.tsx` extension when using React SSR, `.ts` for JSON responses.

### Handler Response Patterns

**Pattern 1: React SSR (HTML Response)**
```typescript
// Simple - uses default layout
import { ui } from '../../lib/router/react/response';
return ui(<Component />);

// With custom layout
import { CustomLayout } from '../ui/layouts/custom';
return ui(<Component />, { layout: <CustomLayout /> });

// Note: Components use <Helmet> to manage their own head elements
```

**Pattern 2: JSON Response**
```typescript
import { json } from '../../lib/router/response';
return json({ data: 'value' });
```

**Pattern 3: Error Response**
```typescript
import { error, notFound } from '../../lib/router/response';
return notFound('Post');
```

**Pattern 4: Redirect**
```typescript
import { redirect } from '../../lib/router/response';
return redirect('/new-url', 302);
```

**Reference Examples (For Future Implementation):**

```typescript
// src/handlers/posts/list.ts
import { json } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

// Simple handler export
export default (async (request, context) => {
  // TODO: Get posts from event store projection
  const posts = [];
  
  return json({
    data: posts,
    meta: {
      total: posts.length,
      timestamp: new Date().toISOString(),
    }
  });
}) as RouteHandler;
```

```typescript
// src/handlers/posts/show.ts
import { json, notFound } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

export default (async (request, context) => {
  const { slug } = context.params;
  
  // TODO: Get post by slug from projection
  const post = null; // await getPostBySlug(slug);
  
  if (!post) {
    return notFound('Post');
  }
  
  return json({
    data: post,
    meta: { timestamp: new Date().toISOString() }
  });
}) as RouteHandler;
```

```typescript
// src/handlers/posts/create.ts
import { json, error } from '../../../lib/router/response';
import type { RouteDefinition, RouteHandler } from '../../../lib/router/types';
import { validateJson } from '../../middleware/validation';

// Handler with middleware
const handler: RouteHandler = async (request, context) => {
  const body = await request.json();
  
  // TODO: Validate and emit PostCreated event
  
  return json({
    data: { id: 'post-123', slug: 'my-first-post', ...body },
    meta: { timestamp: new Date().toISOString() }
  }, 201);
};

// Export as object with middleware
export default {
  handler,
  middleware: [validateJson],
} as RouteDefinition;
```

```typescript
// src/handlers/authors/show.ts
import { json, notFound } from '../../../lib/router/response';
import type { RouteHandler } from '../../../lib/router/types';

export default (async (request, context) => {
  const { slug } = context.params;
  
  // TODO: Get author by slug from projection
  const author = null; // await getAuthorBySlug(slug);
  
  if (!author) {
    return notFound('Author');
  }
  
  // TODO: Get author's posts
  const posts = []; // await getPostsByAuthor(author.id);
  
  return json({
    data: {
      ...author,
      posts,
    },
    meta: { timestamp: new Date().toISOString() }
  });
}) as RouteHandler;
```

### Usage Patterns Comparison

```typescript
// Pattern 1: Static import
import listPosts from './handlers/posts/list';
router.get('/api/posts', listPosts);

// Pattern 2: Dynamic import (recommended)
router.get('/api/posts', import('./handlers/posts/list'));

// Pattern 3: Dynamic import with middleware
router.post('/api/posts', import('./handlers/posts/create'));
// The handler module exports { handler, middleware } - works seamlessly

// Pattern 4: Inline handler (for simple cases)
router.get('/health', async (request, context) => {
  return new Response('OK', { status: 200 });
});
```

**Recommendation**: Use dynamic imports (`import()`) by default for better optimization. Use static imports only for critical routes that need to respond immediately on first request (e.g., health checks).

### Supported Route Patterns

```typescript
// Exact match
/posts
/authors

// Single param (slug or ID)
/posts/:slug
/authors/:slug

// Multiple params
/categories/:categorySlug/posts/:postSlug

// Nested resources
/authors/:authorId/posts

// Query strings (handled via context.query)
/posts?page=1&limit=20&category=tech

// API routes (for admin/CMS management)
/api/schemas
/api/schemas/:id
```

### Example API Responses

**Homepage:**
```json
GET /

{
  "data": {
    "title": "Welcome to My Blog",
    "featured": [],
    "recent": []
  },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

**List Blog Posts:**
```json
GET /posts?page=1&limit=10

{
  "data": [
    {
      "id": "post-123",
      "slug": "getting-started-with-cms",
      "title": "Getting Started with CMS",
      "excerpt": "Learn how to build content websites...",
      "author": { "id": "author-1", "name": "Jane Doe" },
      "publishedAt": "2025-12-01T10:00:00Z"
    }
  ],
  "meta": {
    "total": 42,
    "page": 1,
    "perPage": 10,
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

**Show Author Profile:**
```json
GET /authors/jane-doe

{
  "data": {
    "id": "author-1",
    "slug": "jane-doe",
    "name": "Jane Doe",
    "bio": "Content strategist and writer...",
    "posts": [
      {
        "id": "post-123",
        "slug": "getting-started-with-cms",
        "title": "Getting Started with CMS"
      }
    ]
  },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

### Dynamic Import Performance

**Backend (Bun/Node)**
- Handler loaded once on first request
- Cached for subsequent requests
- Minimal overhead (~1-5ms first hit)
- No overhead after first load

**Frontend (Vite)**
- Handler becomes separate chunk
- Loaded only when route is navigated to
- Significantly reduces initial bundle size
- Perfect for large applications with many routes

**Optional Grouping**: For large applications, you can optionally organize routes into groups by creating helper functions or separate files, but it's not required. The pattern supports both approaches.

## Request/Response Format

### Standard Request Body

All POST/PUT requests accept JSON:

```typescript
// shared/types/api.ts
export interface CreateSchemaRequest {
  name: string;
  fields: FieldDefinition[];
}

export interface CreateContentRequest {
  schemaId: string;
  data: Record<string, unknown>;
}

export interface UpdateContentRequest {
  data: Record<string, unknown>;
}
```

### Standard Response Format

Success responses:

```typescript
// Single resource
{
  "data": { ... },
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}

// Collection
{
  "data": [ ... ],
  "meta": {
    "total": 42,
    "page": 1,
    "perPage": 20,
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

Error responses:

```typescript
{
  "error": "Resource not found",
  "code": "NOT_FOUND",
  "meta": {
    "timestamp": "2025-12-08T12:00:00Z"
  }
}
```

## Middleware

### CORS Middleware (src/middleware/cors.ts)

Backend must support frontend development on separate port:

```typescript
// src/middleware/cors.ts
import type { Middleware } from '../../lib/router/types';

const allowedOrigins = [
  'http://localhost:5173',  // Vite dev server (default)
  'http://localhost:3000',  // Same-origin
];

export const corsMiddleware: Middleware = async (request, context, next) => {
  const origin = request.headers.get('origin');
  const response = await next();
  
  if (origin && allowedOrigins.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  }
  
  return response;
};
```

### Logging Middleware (src/middleware/logging.ts)

```typescript
// src/middleware/logging.ts
import type { Middleware } from '../../lib/router/types';

export const loggingMiddleware: Middleware = async (request, context, next) => {
  const start = Date.now();
  const { method, url } = request;
  
  const response = await next();
  
  const duration = Date.now() - start;
  console.log(`${method} ${url} ${response.status} ${duration}ms`);
  
  return response;
};
```

## Server Entry Point

### Main Server File (src/server.ts)

```typescript
// src/server.ts
import { Router } from '../lib/router';
import { createBunServer } from '../lib/adapters/bun';
import { registerRoutes } from './routes';

const router = new Router();
registerRoutes(router);

const server = createBunServer(router, {
  port: Number(process.env.PORT) || 3000,
  hostname: process.env.HOSTNAME || '127.0.0.1',
  development: process.env.NODE_ENV !== 'production',
});

console.log(`ğŸš€ Server running at http://${server.hostname}:${server.port}`);
```

**Configuration Options:**
- **Port**: Set via `PORT` env var, defaults to `3000`
- **Hostname**: Set via `HOSTNAME` env var, defaults to `127.0.0.1` (localhost only)
  - Use `HOSTNAME=0.0.0.0` for network access
- **Development mode**: Automatic based on `NODE_ENV`

## Runtime Adapters

### Bun Adapter (lib/adapters/bun.ts)

```typescript
import type { Router } from '../router';

export interface BunAdapterOptions {
  port?: number;
  hostname?: string;
  development?: boolean;
}

export function createBunServer(router: Router, options: BunAdapterOptions = {}) {
  const {
    port = 3000,
    hostname = '127.0.0.1',
    development = true,
  } = options;

  return Bun.serve({
    port,
    hostname,
    development,
    fetch: (request) => router.handle(request),
    error(error) {
      console.error('Server error:', error);
      return new Response(
        JSON.stringify({
          error: {
            message: development ? error.message : 'Internal server error',
            stack: development ? error.stack : undefined,
          },
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    },
  });
}
```

**Key Features:**
- Listens on `127.0.0.1` by default (localhost only, more secure)
- Configurable port and hostname
- Development mode shows detailed errors
- Production mode hides error details
- Set `hostname: '0.0.0.0'` for network access

### Future Adapters

Production deployment uses adapters - no direct server execution needed.

**Cloudflare Workers** (future - Phase 4)
- Deploy to Cloudflare's edge network via `wrangler` CLI
- Same Router interface, Cloudflare-specific adapter
- Automatic scaling, global distribution
- Priority: After local development story is solid

**Vercel** (future - Phase 4)
- Deploy via Vercel adapter
- Serverless functions or edge runtime
- Automatic deployment from git

**Netlify** (future - Phase 4)
- Deploy via Netlify adapter
- Netlify Functions or Edge Functions
- Automatic deployment from git

**Node.js** (future - Phase 4)
- Optional adapter for Node.js environments if needed
- Lower priority - adapters handle most production use cases
- Would use standard Node HTTP server

**Key Philosophy:**
- **Development**: Direct execution with Bun (`bun --hot src/server.ts`)
- **Production**: Deploy through adapters (Cloudflare, Vercel, Netlify)
- **No `start` script**: Production runs through platform-specific deployment tools
- **Adapter pattern**: Each platform gets its own adapter implementation

## CLI Architecture (Future - Phase 4)

**Note**: CLI implementation is deferred to Phase 4. Focus is currently on getting the HTTP routing and local development experience right first.

### Overview

The CLI will follow the same pattern as HTTP routing, providing a consistent developer experience:

```typescript
// src/cli.ts (Phase 4 - future implementation)
import { CLI } from '../lib/cli';
import { registerCommands } from './commands';

const cli = new CLI();
registerCommands(cli);

cli.run(process.argv);
```

### Command Registration Pattern

Similar to Laravel's routing, but for CLI commands:

```typescript
// src/commands.ts (Phase 4 - future)
import { CLI } from '../lib/cli';

// Command handlers
import listPosts from './commands/posts/list';
import createPost from './commands/posts/create';
import listAuthors from './commands/authors/list';
import listEvents from './commands/events/list';
import replayEvents from './commands/events/replay';

export function registerCommands(cli: CLI) {
  // Post commands
  cli.command('posts:list', listPosts)
     .description('List all blog posts');
  
  cli.command('posts:create', createPost)
     .description('Create a new blog post');
  
  // Author commands
  cli.command('authors:list', listAuthors)
     .description('List all authors');
  
  // Event commands
  cli.command('events:list', listEvents)
     .description('List all events from the event store');
  
  cli.command('events:replay', replayEvents)
     .description('Replay events to rebuild projections');
}
```

### Command Handler Structure

Command handlers would mirror HTTP handlers but work with CLI context:

```typescript
// src/commands/posts/list.ts (Phase 4 - future)
import type { CommandHandler } from '../../lib/cli/types';

export default (async (args, context) => {
  // Access event store
  const posts = []; // TODO: Get from event store projection
  
  // Output to console
  console.table(posts.map(p => ({
    id: p.id,
    title: p.title,
    author: p.author.name,
    published: p.publishedAt
  })));
  
  return 0; // Exit code
}) as CommandHandler;
```

### CLI vs HTTP Routing Comparison

| Aspect | HTTP Routing | CLI Routing |
|--------|-------------|-------------|
| **Entry Point** | `src/server.ts` | `src/cli.ts` |
| **Route File** | `src/routes.ts` | `src/commands.ts` |
| **Handlers** | `src/handlers/*` | `src/commands/*` |
| **Registration** | `router.get(path, handler)` | `cli.command(name, handler)` |
| **Context** | `{ params, query }` | `{ args, flags }` |
| **Output** | `Response` object | Exit code + stdout |
| **Middleware** | CORS, auth, logging | Validation, auth, logging |

### Benefits of This Pattern

1. **Consistent Interface**: Same pattern for web and CLI
2. **Shared Logic**: Handlers can use same commands/event store
3. **Testable**: CLI commands can be tested like HTTP routes
4. **Discoverable**: All commands in one file (`src/commands.ts`)
5. **Extensible**: Easy to add new commands without touching core

### Example Usage

```bash
# List posts
bun run src/cli.ts posts:list

# Create post interactively
bun run src/cli.ts posts:create --title "My First Post" --author jane-doe

# Replay events for specific date
bun run src/cli.ts events:replay --date 2025-12-08

# List posts by author
bun run src/cli.ts posts:list --author jane-doe
```

### Package.json Scripts (Phase 4 - future)

```json
{
  "scripts": {
    "dev": "vite",
    "server": "bun run src/server.ts",
    "cms": "bun run src/cli.ts",
    "dev:all": "concurrently \"bun run server\" \"bun run dev\""
  }
}
```

Then users can run: `bun run cms posts:list`

## Layout System

### Overview

The layout system provides consistent HTML structure across all server-rendered pages. Layouts are React components that receive page content as `children` and define the overall document structure.

### Default Layout

A default layout is automatically loaded from `src/ui/layouts/default.tsx` when no layout is specified:

```typescript
// src/ui/layouts/default.tsx
import type { ReactNode } from 'react';
import { Helmet } from 'react-helmet-async';

interface DefaultLayoutProps {
  children: ReactNode;
}

export function DefaultLayout({ children }: DefaultLayoutProps) {
  return (
    <>
      <Helmet>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      </Helmet>
      <main>
        {children}
      </main>
    </>
  );
}
```

**Key Points:**
- Layout defines HTML structure (no `<html>`, `<head>`, or `<body>` tags)
- Uses `<Helmet>` for default meta tags
- Receives page component as `children` prop
- Automatically used if no custom layout specified

### Custom Layouts

Create custom layouts for different page types:

```typescript
// src/ui/layouts/custom.tsx
import type { ReactNode } from 'react';
import { Helmet } from 'react-helmet-async';

interface CustomLayoutProps {
  children: ReactNode;
}

export function CustomLayout({ children }: CustomLayoutProps) {
  return (
    <>
      <Helmet>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="/custom-styles.css" />
      </Helmet>
      <header>
        <nav>Custom Navigation</nav>
      </header>
      <main className="custom-layout">
        {children}
      </main>
      <footer>
        <p>Custom Footer</p>
      </footer>
    </>
  );
}
```

### Using Layouts in Handlers

**Default Layout (Automatic):**
```typescript
// src/handlers/home.tsx
import { ui } from '../../lib/router/react/response';
import { Homepage } from '../ui/components/Homepage';

export default function home(ctx: RequestContext): Promise<Response> {
  // Uses default layout automatically
  return ui(<Homepage />);
}
```

**Custom Layout:**
```typescript
// src/handlers/example-custom-layout.tsx
import { ui } from '../../lib/router/react/response';
import { Homepage } from '../ui/components/Homepage';
import { CustomLayout } from '../ui/layouts/custom';

export default function handler(ctx: RequestContext): Promise<Response> {
  // Explicitly use custom layout
  return ui(<Homepage />, { 
    layout: <CustomLayout /> 
  });
}
```

### Head Management with react-helmet-async

Both layouts and components can use `<Helmet>` to manage head elements:

**Layout sets defaults:**
```typescript
<Helmet>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/global.css" />
</Helmet>
```

**Component overrides/extends:**
```typescript
// src/ui/components/Homepage.tsx
import { Helmet } from 'react-helmet-async';

export function Homepage() {
  return (
    <>
      <Helmet>
        <title>Welcome - Project Conduit</title>
        <meta name="description" content="Homepage description" />
      </Helmet>
      <h1>Welcome</h1>
    </>
  );
}
```

**Result:** Component-specific tags override/extend layout defaults. The `ui()` function extracts all helmet data and injects it into the final HTML document.

### Layout Best Practices

1. **Keep layouts simple**: Focus on structure, not content
2. **Use Helmet for head elements**: No manual HTML string building
3. **Default layout for consistency**: Most pages should use default layout
4. **Custom layouts sparingly**: Only when page structure differs significantly
5. **No logic in layouts**: Keep them presentational
6. **Children prop**: Always accept and render `children`

### Layout Discovery

The `ui()` function loads layouts in this order:

1. **Explicit layout**: If `layout` option provided, use it
2. **Default layout**: Otherwise, load from `src/ui/layouts/default.tsx`

No configuration needed - layouts are automatically discovered by convention.

## Frontend Integration

### API Provider Pattern

The UI layer includes an API provider component that manages connection configuration:

**Note**: This is a reference pattern. Phase 3 will implement a simple homepage without ApiProvider. Users can implement this pattern based on their needs.

```typescript
// src/ui/components/ApiProvider.tsx (Reference - not implemented in Phase 3)
import { createContext, useContext, ReactNode } from 'react';

const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000';

interface ApiContextValue {
  baseUrl: string;
  getSchemas: () => Promise<Schema[]>;
  createContent: (request: CreateContentRequest) => Promise<Content>;
  // ... more methods
}

const ApiContext = createContext<ApiContextValue | null>(null);

export function ApiProvider({ 
  children, 
  baseUrl = API_BASE 
}: { 
  children: ReactNode; 
  baseUrl?: string;
}) {
  const api: ApiContextValue = {
    baseUrl,
    
    async getSchemas() {
      const response = await fetch(`${baseUrl}/api/schemas`);
      const { data } = await response.json();
      return data;
    },
    
    async createContent(request: CreateContentRequest) {
      const response = await fetch(`${baseUrl}/api/content`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });
      const { data } = await response.json();
      return data;
    },
    
    // ... more methods
  };
  
  return <ApiContext.Provider value={api}>{children}</ApiContext.Provider>;
}

export function useApi() {
  const context = useContext(ApiContext);
  if (!context) {
    throw new Error('useApi must be used within ApiProvider');
  }
  return context;
}
```

### Phase 3 Implementation (Simple Homepage)

**Current Implementation:**

The homepage is server-side rendered with react-helmet-async for head management:

```typescript
// src/ui/components/Homepage.tsx
import { Helmet } from 'react-helmet-async';
import './Homepage.css';

export function Homepage() {
  return (
    <>
      <Helmet>
        <title>Project Conduit</title>
        <meta name="description" content="Event-sourced CMS for LLM-native workflows" />
        <link rel="stylesheet" href="/src/ui/components/Homepage.css" />
      </Helmet>
      <div className="homepage">
        <header className="homepage-header">
          <h1>Project Conduit</h1>
          <p className="tagline">Event-sourced CMS for LLM-native workflows</p>
        </header>
        <main className="homepage-content">
          <section>
            <h2>Welcome</h2>
            <p>This is a server-side rendered React component with react-helmet-async.</p>
          </section>
        </main>
      </div>
    </>
  );
}
```

**Handler:**
```typescript
// src/handlers/home.tsx
import type { RequestContext } from '../../lib/router/types';
import { ui } from '../../lib/router/react/response';
import { Homepage } from '../ui/components/Homepage';

export default function home(ctx: RequestContext): Promise<Response> {
  return ui(<Homepage />);
}
```

**Key Features:**
- Server-side rendering (SSR) for initial page load
- react-helmet-async for head management
- Default layout applied automatically
- Component controls its own metadata
- CSS imported via Vite's module system

### Vue Provider Alternative

For Vue projects, a similar composable pattern:

```typescript
// src/ui/components/ApiProvider.vue (or use provide/inject)
import { provide, inject } from 'vue';

const ApiSymbol = Symbol('api');

export function provideApi(baseUrl = 'http://localhost:3000') {
  provide(ApiSymbol, {
    baseUrl,
    async getSchemas() { /* ... */ },
    async createContent() { /* ... */ },
  });
}

export function useApi() {
  const api = inject(ApiSymbol);
  if (!api) throw new Error('useApi requires provideApi');
  return api;
}
```

### Environment Configuration

```bash
# .env.development (root level)
VITE_API_URL=http://localhost:3000

# .env.production (root level)
VITE_API_URL=https://api.yourdomain.com
```

## Development Workflow

### Build Tools

**Backend (Bun)**
- Use Bun for running the HTTP server: `bun run src/server.ts`
- Fast startup, native TypeScript support
- No build step needed for development

**Frontend (Vite)**
- Use Vite for UI bundling and dev server
- Optimized code splitting and lazy loading
- Best-in-class HMR (Hot Module Replacement)
- Production builds automatically optimize bundle size

**Why This Combination?**
- Bun excels at server-side TypeScript execution
- Vite excels at frontend bundling and optimization
- Both work together seamlessly via CORS

### Running Backend Only

```bash
cd /home/ubuntu/sites/ai-cms
bun run dev:server
# Server runs on http://127.0.0.1:3000 with hot reload
```

Or without hot reload:
```bash
bun src/server.ts
```

**Network access:**
```bash
HOSTNAME=0.0.0.0 bun run dev:server
# Server accessible from network on http://0.0.0.0:3000
```

### Running UI Only

```bash
bun run dev:ui
# UI dev server runs on http://127.0.0.1:5173
# Proxies /api requests to http://localhost:3000
```

**Network access:**
```bash
HOSTNAME=0.0.0.0 bun run dev:ui
```

### Running Full Stack (Recommended)

```bash
# Localhost only (default, more secure)
bun run dev
# Backend: http://127.0.0.1:3000
# Frontend: http://127.0.0.1:5173

# Network accessible (for testing on other devices)
bun run dev:network
# OR
HOSTNAME=0.0.0.0 bun run dev
# Backend: http://0.0.0.0:3000
# Frontend: http://0.0.0.0:5173 (shows network IP)
```

**Key Point**: Single `HOSTNAME` environment variable controls both servers for simplicity.

Both servers start simultaneously and run independently. Press Ctrl+C to stop both.

### Package Scripts (package.json)

```json
{
  "scripts": {
    "dev": "bun run dev:server & bun run dev:ui",
    "dev:server": "bun --hot src/server.ts",
    "dev:ui": "vite",
    "dev:network": "HOSTNAME=0.0.0.0 bun run dev",
    "build": "tsc --noEmit && vite build"
  }
}
```

**Key Points:**
- **No backend build needed**: Bun executes TypeScript directly
- **`dev`**: Run both server and UI dev servers in parallel (main command, localhost only)
- **`dev:server`**: Run backend server with hot reload (`--hot` flag)
- **`dev:ui`**: Run Vite dev server for UI development
- **`dev:network`**: Run both servers accessible from network (0.0.0.0)
- **`build`**: Type check with `tsc`, then build UI with Vite
  - Vite uses esbuild which strips types without checking
  - `tsc --noEmit` runs first to catch type errors
  - Build fails if type errors exist
  - Only UI assets are built (no backend compilation)

**Parallel Execution:**
- The `&` operator in `dev` script runs both servers concurrently
- Both servers start simultaneously and run independently
- Ctrl+C stops both servers

**Network Configuration:**
- **Default (`dev`)**: Both servers listen on `127.0.0.1` (localhost only, secure)
- **Network mode (`dev:network`)**: Both servers listen on `0.0.0.0` (accessible from network)
- **Single environment variable**: `HOSTNAME` controls both backend and frontend
- **Manual override**: `HOSTNAME=0.0.0.0 bun run dev` to enable network access

### Vite Configuration (vite.config.ts)

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  
  root: 'src/ui',
  
  build: {
    outDir: '../../public',
    emptyOutDir: true,
    sourcemap: true,
  },
  
  server: {
    host: process.env.HOSTNAME || '127.0.0.1',  // Same as backend
    port: 5173,
    strictPort: true,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
    },
  },
  
  base: '/',
});
```

**Key Configuration:**
- **host**: Uses `HOSTNAME` env var (same as backend), defaults to `127.0.0.1`
- **proxy**: API requests forwarded to backend during development
- **root**: Source directory is `src/ui`
- **build.outDir**: Production builds go to `public/`

**Production Deployment:**
- No `start` script needed - production runs through deployment adapters
- **Cloudflare Workers**: Use `wrangler` CLI with Cloudflare adapter
- **Vercel**: Deploy via Vercel adapter (automatically detected)
- **Netlify**: Deploy via Netlify adapter
- **Node.js**: If needed, use Node adapter (future)
- Each adapter handles the runtime-specific deployment process

## Testing Strategy

### Handler Unit Tests

Test individual handlers in isolation:

```typescript
// src/handlers/posts/__tests__/list.test.ts
import { describe, it, expect } from 'bun:test';
import listPosts from '../list';

describe('listPosts handler', () => {
  it('returns empty array when no posts exist', async () => {
    const request = new Request('http://localhost:3000/posts');
    const context = { params: {}, query: new URLSearchParams() };
    
    const response = await listPosts(request, context);
    expect(response.status).toBe(200);
    
    const { data } = await response.json();
    expect(Array.isArray(data)).toBe(true);
  });

  it('filters posts by query params', async () => {
    const request = new Request('http://localhost:3000/posts?category=tech');
    const context = { 
      params: {}, 
      query: new URLSearchParams('category=tech') 
    };
    
    const response = await listPosts(request, context);
    const { data } = await response.json();
    
    // TODO: verify filtering works
  });
});
```

### Integration Tests

Test complete router with all routes:

```typescript
// src/__tests__/routes.test.ts
import { Router } from '../lib/router';
import { registerRoutes } from './routes';

describe('API Routes', () => {
  const router = new Router();
  registerRoutes(router);

  it('GET / returns 200', async () => {
    const request = new Request('http://localhost:3000/');
    const response = await router.handle(request);
    expect(response.status).toBe(200);
  });

  it('GET /posts/:slug returns post', async () => {
    const request = new Request('http://localhost:3000/posts/my-first-post');
    const response = await router.handle(request);
    expect(response.status).toBe(200);
    
    const { data } = await response.json();
    expect(data.slug).toBe('my-first-post');
  });

  it('unknown routes return 404', async () => {
    const request = new Request('http://localhost:3000/unknown');
    const response = await router.handle(request);
    expect(response.status).toBe(404);
  });
});
```

### Running Tests

```bash
bun test src/
```

## Implementation Phases

### Phase 1: Core Router (Foundation) - **PRIORITY**
- [x] Implement `lib/router/index.ts` with pattern matching
- [x] Implement `lib/router/types.ts` with dynamic import support
- [x] Add `lib/router/response.ts` helpers (json, error, notFound, redirect)
- [x] Add `lib/router/react/response.tsx` helpers (ui for React SSR)
- [x] Create Bun adapter (`lib/adapters/bun.ts`)
- [x] Write router unit tests

### Phase 2: Basic API Routes - **PRIORITY**
- [x] Set up `src/server.ts` entry point
- [x] Create `src/routes.ts` with homepage route
- [x] Implement homepage handler (`handlers/home.tsx`) with React SSR
- [x] Add React SSR utilities (`lib/router/react/response.tsx`)
- [x] Add CORS middleware
- [x] Add logging middleware
- [x] Test with curl/browser

**Note**: Phase 2 now includes React SSR support via the `ui()` helper function. Handlers can return either JSON (via `json()`) or server-rendered React (via `ui()`). Additional routes (posts, authors, etc.) shown in examples are for reference - users will implement as needed.

### Phase 3: Frontend Integration
- [x] Set up Vite configuration
- [x] Create `src/ui/` structure
- [x] Build simple homepage component with react-helmet-async
- [x] Implement layout system (default + custom layouts)
- [x] Integrate react-helmet-async for head management
- [x] Test end-to-end flow (SSR + layouts + helmet)

**Note**: Phase 3 focuses on a minimal homepage example with proper head management and layout system. ApiProvider pattern and full CRUD UI are left for users to implement based on their needs.

### Phase 4: CLI & Production Deployment (Future)
- [ ] Design CLI architecture (`lib/cli/`)
- [ ] Implement command registration system
- [ ] Create `src/cli.ts` entry point
- [ ] Create `src/commands.ts` command registry
- [ ] Build example commands (posts:list, events:replay)
- [ ] Implement Cloudflare Workers adapter
- [ ] Add deployment configuration
- [ ] Test production build
- [ ] Document deployment process

## Success Criteria

### âœ… Completed (Phases 1-3)

1. **Backend runs independently** without any frontend code
2. **Bun server starts quickly** (<100ms) with hot reload support
3. **Zero framework-specific code** in `lib/` directory (except framework subdirs)
4. **Framework utilities properly organized** (lib/router/react/, lib/router/vue/)
5. **React SSR works seamlessly** via `ui()` helper function
6. **Layout system implemented** with default layout and custom layout support
7. **react-helmet-async integrated** for component-based head management
8. **Dynamic imports work seamlessly** for lazy-loaded handlers
9. **All API routes follow consistent patterns** (REST conventions)
10. **Full TypeScript type safety** between client and server
11. **Local development is smooth** with CORS and hot reload
12. **Routes are easy to add/modify** (Laravel-style simplicity)
13. **Handlers can return JSON or HTML** using appropriate helpers
14. **Components control their own metadata** via `<Helmet>` tags
15. **No manual HTML string building** - layout system handles structure

### ğŸ”œ Deferred Success Criteria (Phase 4)
- CLI commands work with same patterns as HTTP routes
- Cloudflare Workers deployment
- Node.js adapter support
- OpenAPI spec generation

## Open Questions

1. ~~Should we use a routing library (e.g., Hono, itty-router) or build custom?~~ **Decision: Build custom with dynamic import support**
2. How do we handle file uploads (multipart/form-data)?
3. Should we add request validation middleware (e.g., Zod)?
4. What's the authentication strategy for protected routes?
5. Should we generate OpenAPI specs automatically? (future consideration)

## References

- Web Fetch API: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
- Bun HTTP Server: https://bun.sh/docs/api/http
- Dynamic Imports: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import
- React Helmet Async: https://github.com/staylor/react-helmet-async
- Cloudflare Workers (future): https://developers.cloudflare.com/workers/

---

**Status**: Phases 1-3 completed. React SSR with layout system and react-helmet-async fully implemented and tested.
