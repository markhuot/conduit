# HTTP Error Handling Specification

**Spec ID**: 2025121101  
**Created**: 2025-12-11  
**Status**: ✅ Implemented  
**Phase**: Foundation

## Overview

This spec defines a type-safe error handling system for HTTP responses. Handlers and middleware throw structured Error instances that carry HTTP metadata (status code, headers). The router automatically catches these errors and converts them to appropriate HTTP responses.

## Final Decisions

1. ✅ **Throwing is preferred** - Errors are thrown, not returned
2. ✅ **Redirects are errors** - `RedirectError` is a special error type for redirects
3. ✅ **Minimal logging** - Only "Router error:" log exists (from router catch block)
4. ✅ **Production redaction** - Show generic "An error occurred" for unexpected errors in production
5. ✅ **No backwards compatibility** - Old response helpers removed (except `json` and `noContent`)

## Implementation Status

- ✅ Error classes defined in `lib/router/errors.ts`
- ✅ Router catches and converts errors in `lib/router/index.ts`
- ✅ Bun adapter uses `errorToResponse()` in `lib/adapters/bun.ts`
- ✅ Auth middleware updated to throw errors
- ✅ Admin handlers updated to throw errors
- ✅ All tests passing (41 router tests, 6 auth tests, 12 admin tests)
- ✅ Old response helpers removed (kept `json()` and `noContent()` only)

## Problem Statement

Currently, error responses are created by calling helper functions like `notFound()`, `unauthorized()`, etc., which return Response objects. This has several limitations:

1. **Not discoverable**: In middleware, you have to return a Response which interrupts the middleware chain
2. **Verbose**: Requires importing multiple helper functions
3. **No centralized error handling**: Error formatting is scattered across handlers
4. **Hard to extend**: Adding custom headers (like redirect Location) requires different patterns

**Current Pattern:**
```typescript
// lib/adapters/bun.ts
error(error: Error): Response {
  return new Response(
    JSON.stringify({
      error: {
        message: development ? error.message : 'Internal server error',
        stack: development ? error.stack : undefined,
      },
    }),
    {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}

// In handlers - have to return Response
if (!user) {
  return unauthorized('Please log in');
}

// Can't easily redirect with custom headers
return new Response(null, {
  status: 302,
  headers: {
    Location: '/login',
    'Set-Cookie': 'message=Please%20log%20in',
  },
});
```

## Desired Pattern

Handlers and middleware should throw structured errors:

```typescript
// Throw errors with HTTP metadata
throw new NotFoundError('User not found');
throw new UnauthorizedError('Please log in');
throw new RedirectError('/login', { 
  headers: { 'Set-Cookie': 'message=Please%20log%20in' } 
});

// Router catches and converts to Response automatically
```

## Design Principles

1. **Type Safety**: All errors are TypeScript classes with proper types
2. **Extensibility**: Easy to add custom error types
3. **HTTP-Native**: Errors carry status codes and headers
4. **Centralized**: Router handles error-to-response conversion
5. **Developer Experience**: Clear, discoverable error types

## Architecture

### Base Error Class

```typescript
// lib/router/errors.ts

/**
 * Base HTTP error with status code and headers
 */
export class HttpError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public headers: Record<string, string> = {},
    public code?: string
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}
```

### Standard HTTP Errors

```typescript
// lib/router/errors.ts

export class NotFoundError extends HttpError {
  constructor(message = 'Not found', headers: Record<string, string> = {}) {
    super(message, 404, headers, 'NOT_FOUND');
  }
}

export class UnauthorizedError extends HttpError {
  constructor(message = 'Unauthorized', headers: Record<string, string> = {}) {
    super(message, 401, headers, 'UNAUTHORIZED');
  }
}

export class ForbiddenError extends HttpError {
  constructor(message = 'Forbidden', headers: Record<string, string> = {}) {
    super(message, 403, headers, 'FORBIDDEN');
  }
}

export class BadRequestError extends HttpError {
  constructor(
    message: string, 
    headers: Record<string, string> = {},
    public details?: unknown
  ) {
    super(message, 400, headers, 'BAD_REQUEST');
  }
}

export class ConflictError extends HttpError {
  constructor(message: string, headers: Record<string, string> = {}) {
    super(message, 409, headers, 'CONFLICT');
  }
}

export class ValidationError extends HttpError {
  constructor(
    message: string,
    public errors: Record<string, string[]>,
    headers: Record<string, string> = {}
  ) {
    super(message, 422, headers, 'VALIDATION_ERROR');
  }
}

export class InternalServerError extends HttpError {
  constructor(message = 'Internal server error', headers: Record<string, string> = {}) {
    super(message, 500, headers, 'INTERNAL_SERVER_ERROR');
  }
}
```

### Redirect Error

Redirects are a special case that carry a Location header:

```typescript
// lib/router/errors.ts

export class RedirectError extends HttpError {
  constructor(
    location: string,
    options: {
      status?: 301 | 302 | 307 | 308;
      headers?: Record<string, string>;
    } = {}
  ) {
    const { status = 302, headers = {} } = options;
    super('Redirect', status, { ...headers, Location: location });
  }
}
```

### Error Response Converter

The router converts errors to JSON responses:

```typescript
// lib/router/errors.ts

export function errorToResponse(error: Error, development = false): Response {
  // Handle HttpError instances
  if (error instanceof HttpError) {
    const body: any = {
      error: {
        message: error.message,
        code: error.code,
      },
    };

    // Add validation errors if present
    if (error instanceof ValidationError) {
      body.error.errors = error.errors;
    }

    // Add details if present
    if ('details' in error && error.details) {
      body.error.details = error.details;
    }

    // Add stack trace in development
    if (development) {
      body.error.stack = error.stack;
    }

    return new Response(JSON.stringify(body), {
      status: error.statusCode,
      headers: {
        'Content-Type': 'application/json',
        ...error.headers,
      },
    });
  }

  // Handle unexpected errors (not HttpError)
  console.error('Unexpected error:', error);
  return new Response(
    JSON.stringify({
      error: {
        message: development ? error.message : 'Internal server error',
        code: 'INTERNAL_SERVER_ERROR',
        stack: development ? error.stack : undefined,
      },
    }),
    {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}
```

### Special Case: Redirects

Redirect errors should return empty body (not JSON):

```typescript
// lib/router/errors.ts (updated errorToResponse)

export function errorToResponse(error: Error, development = false): Response {
  // Handle RedirectError specially - no JSON body
  if (error instanceof RedirectError) {
    return new Response(null, {
      status: error.statusCode,
      headers: error.headers,
    });
  }

  // ... rest of the function
}
```

## Router Integration

### Updated Router Error Handling

```typescript
// lib/router/index.ts

import { errorToResponse } from './errors';

export class Router {
  // ... existing code ...

  async handle(request: Request): Promise<Response> {
    try {
      // ... existing routing logic ...
    } catch (err) {
      // Convert errors to responses
      return errorToResponse(err as Error, this.development);
    }
  }
}
```

### Bun Adapter Updates

```typescript
// lib/adapters/bun.ts

import { errorToResponse } from '../router/errors';

export function createBunServer(router: Router, options: BunAdapterOptions = {}) {
  const { development = true } = options;

  return Bun.serve({
    // ... existing config ...

    error(error: Error): Response {
      console.error('Server error:', error);
      return errorToResponse(error, development);
    },
  });
}
```

## Usage Examples

### Basic Usage in Handlers

```typescript
// src/handlers/posts/show.ts
import type { RequestContext } from '../../../lib/router/types';
import { json } from '../../../lib/router/response';
import { NotFoundError } from '../../../lib/router/errors';

export default async function show(ctx: RequestContext): Promise<Response> {
  const { slug } = ctx.params;
  const post = await findPostBySlug(slug);

  if (!post) {
    throw new NotFoundError(`Post "${slug}" not found`);
  }

  return json({ data: post });
}
```

### Authentication Middleware

```typescript
// lib/auth/middleware.ts
import { UnauthorizedError } from '../router/errors';

export function requireAuth(): Middleware {
  return async (ctx, next) => {
    const sessionId = ctx.request.headers.get('cookie')?.match(/session=([^;]+)/)?.[1];

    if (!sessionId) {
      throw new UnauthorizedError('Authentication required');
    }

    const session = await getSession(sessionId);
    if (!session?.userId) {
      throw new UnauthorizedError('Invalid or expired session');
    }

    ctx.user = await getUser(session.userId);
    return next();
  };
}
```

### Redirect After Login

```typescript
// src/handlers/login.ts
import { RedirectError } from '../../lib/router/errors';
import { setFlashMessage } from '../../lib/session';

export default async function login(ctx: RequestContext): Promise<Response> {
  const { email, password } = await ctx.request.json();
  const user = await authenticateUser(email, password);

  if (!user) {
    throw new RedirectError('/login', {
      status: 302,
      headers: {
        'Set-Cookie': await createFlashCookie('error', 'Invalid credentials'),
      },
    });
  }

  // Success - redirect to dashboard
  throw new RedirectError('/dashboard', {
    status: 302,
    headers: {
      'Set-Cookie': await createSessionCookie(user.id),
    },
  });
}
```

### Validation Errors

```typescript
// src/handlers/posts/create.ts
import { ValidationError } from '../../../lib/router/errors';

export default async function create(ctx: RequestContext): Promise<Response> {
  const body = await ctx.request.json();
  
  const errors: Record<string, string[]> = {};
  
  if (!body.title) {
    errors.title = ['Title is required'];
  } else if (body.title.length < 3) {
    errors.title = ['Title must be at least 3 characters'];
  }
  
  if (!body.body) {
    errors.body = ['Body is required'];
  }
  
  if (Object.keys(errors).length > 0) {
    throw new ValidationError('Validation failed', errors);
  }

  // Create post...
  return json({ data: post }, { status: 201 });
}
```

### Custom Headers

```typescript
// Rate limiting example
throw new UnauthorizedError('Rate limit exceeded', {
  'Retry-After': '3600',
  'X-RateLimit-Remaining': '0',
});
```

## Migration Strategy

### Phase 1: Add Error Classes
1. Create `lib/router/errors.ts` with all error classes
2. Add `errorToResponse()` converter function
3. Write unit tests for error classes

### Phase 2: Update Router
1. Update `lib/router/index.ts` to catch and convert errors
2. Update `lib/adapters/bun.ts` to use `errorToResponse()`
3. Keep existing response helpers (`json`, `redirect`, etc.) for backwards compatibility

### Phase 3: Migrate Existing Code
1. Update authentication middleware to throw errors
2. Update handler examples in documentation
3. Keep old helpers deprecated but functional

### Backwards Compatibility

The existing response helpers remain functional:

```typescript
// Old pattern - still works
return notFound('Post not found');
return unauthorized('Please log in');

// New pattern - preferred
throw new NotFoundError('Post not found');
throw new UnauthorizedError('Please log in');
```

Both patterns coexist. The error classes are the preferred approach going forward.

## Benefits

### 1. Better Control Flow

```typescript
// Before - have to return early
if (!user) {
  return unauthorized();
}
// More code here...

// After - throw and stop execution
if (!user) {
  throw new UnauthorizedError();
}
// No need for else block
```

### 2. Cleaner Middleware

```typescript
// Before - interrupts middleware chain
export function requireAuth(): Middleware {
  return async (ctx, next) => {
    if (!ctx.user) {
      return unauthorized('Please log in');
    }
    return next();
  };
}

// After - throws and router handles it
export function requireAuth(): Middleware {
  return async (ctx, next) => {
    if (!ctx.user) {
      throw new UnauthorizedError('Please log in');
    }
    return next();
  };
}
```

### 3. Consistent Error Format

All errors converted to same JSON structure:

```json
{
  "error": {
    "message": "Post not found",
    "code": "NOT_FOUND"
  }
}
```

With validation errors:

```json
{
  "error": {
    "message": "Validation failed",
    "code": "VALIDATION_ERROR",
    "errors": {
      "title": ["Title is required"],
      "body": ["Body must be at least 10 characters"]
    }
  }
}
```

### 4. Type-Safe Extensions

Easy to add custom errors:

```typescript
// Custom error for your app
export class PaymentRequiredError extends HttpError {
  constructor(message = 'Payment required', headers: Record<string, string> = {}) {
    super(message, 402, headers, 'PAYMENT_REQUIRED');
  }
}
```

## Testing

### Unit Tests for Error Classes

```typescript
// lib/router/__tests__/errors.test.ts
import { describe, it, expect } from 'bun:test';
import {
  NotFoundError,
  UnauthorizedError,
  RedirectError,
  ValidationError,
  errorToResponse,
} from '../errors';

describe('HTTP Errors', () => {
  it('NotFoundError has correct status code', () => {
    const error = new NotFoundError('Resource not found');
    expect(error.statusCode).toBe(404);
    expect(error.code).toBe('NOT_FOUND');
    expect(error.message).toBe('Resource not found');
  });

  it('RedirectError includes Location header', () => {
    const error = new RedirectError('/dashboard');
    expect(error.statusCode).toBe(302);
    expect(error.headers.Location).toBe('/dashboard');
  });

  it('ValidationError includes field errors', () => {
    const errors = {
      email: ['Email is required'],
      password: ['Password too short'],
    };
    const error = new ValidationError('Validation failed', errors);
    expect(error.statusCode).toBe(422);
    expect(error.errors).toEqual(errors);
  });

  it('errorToResponse converts NotFoundError to JSON', () => {
    const error = new NotFoundError('User not found');
    const response = errorToResponse(error, false);

    expect(response.status).toBe(404);
    expect(response.headers.get('Content-Type')).toBe('application/json');
  });

  it('errorToResponse converts RedirectError to redirect', () => {
    const error = new RedirectError('/login');
    const response = errorToResponse(error, false);

    expect(response.status).toBe(302);
    expect(response.headers.get('Location')).toBe('/login');
    expect(response.body).toBeNull();
  });
});
```

### Integration Tests

```typescript
// lib/router/__tests__/error-handling.test.ts
import { describe, it, expect } from 'bun:test';
import { Router } from '../index';
import { NotFoundError, UnauthorizedError } from '../errors';

describe('Router Error Handling', () => {
  it('catches NotFoundError and returns 404', async () => {
    const router = new Router();
    router.get('/test', () => {
      throw new NotFoundError('Test not found');
    });

    const request = new Request('http://localhost/test');
    const response = await router.handle(request);

    expect(response.status).toBe(404);
    const body = await response.json();
    expect(body.error.message).toBe('Test not found');
    expect(body.error.code).toBe('NOT_FOUND');
  });

  it('catches UnauthorizedError in middleware', async () => {
    const router = new Router();
    
    const authMiddleware = async (ctx, next) => {
      throw new UnauthorizedError('Not logged in');
    };
    
    router.get('/protected', () => ({ data: 'secret' }), [authMiddleware]);

    const request = new Request('http://localhost/protected');
    const response = await router.handle(request);

    expect(response.status).toBe(401);
  });
});
```

## Open Questions

1. **Should we add rate limiting errors?** (e.g., `TooManyRequestsError` with 429 status)
2. **How should we handle error logging?** Should errors be logged automatically or left to handlers?
3. **Should we support error recovery/retry logic?** Or keep it simple?
4. **Do we need error context (like request ID)?** For debugging in production

## Success Criteria

- [ ] All error classes defined in `lib/router/errors.ts`
- [ ] `errorToResponse()` function converts errors correctly
- [ ] Router catches and converts errors in `handle()` method
- [ ] Bun adapter uses `errorToResponse()` in error handler
- [ ] Redirect errors return proper redirect responses (no JSON body)
- [ ] Validation errors include field-level error details
- [ ] All tests passing
- [ ] Documentation updated with error handling examples
- [ ] Existing response helpers still work (backwards compatible)

## References

- HTTP Status Codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
- Error Handling Patterns: https://www.typescriptlang.org/docs/handbook/2/narrowing.html
- Express.js Error Handling: https://expressjs.com/en/guide/error-handling.html

---

**Next Steps**: Review this spec and discuss approach before implementing.
