# Admin Authentication & Infrastructure Specification

**Spec ID**: 2025120802  
**Created**: 2025-12-08  
**Updated**: 2025-12-08 (Merged with 2025120803)  
**Status**: Draft  
**Phase**: Admin Foundation  
**Dependencies**: 2025120801-routing.md

## Overview

This spec defines the complete admin system for Project Conduit including authentication, layout management, and logging. The admin panel is a **drop-in library feature** with handlers and UI included in `lib/`, ready to use without custom implementation.

**Key Features:**
1. Simple, secure login flow with session management
2. Container-based layout system for admin pages
3. Configurable request/response logging with verbosity levels
4. Single-line drop-in: `router.group('/admin', adminRoutes)`

## Design Principles

1. **Simple & Secure**: Start with basic authentication, plan for extensions
2. **Route Grouping**: Organize admin routes together for clarity
3. **Drop-in Feature**: Admin panel lives in `lib/` as a reusable component
4. **Service Container**: Pluggable services via DI container pattern (moved to `src/`)
5. **Session-Based**: Use HTTP-only cookies with pluggable storage backends
6. **Platform Native**: Embrace HTML forms and standard web patterns
7. **Framework Agnostic**: Auth system works with any frontend framework
8. **No Prop Drilling**: Container pattern eliminates passing config around

## Goals

- Implement `/admin/login` route with simple login form (no CSS initially)
- Create route grouping system (`router.group('/admin', ...)`)
- Build drop-in admin panel in `lib/admin/`
- Establish service container for pluggable backends (in `src/container.ts`)
- Create `config/` directory for user configuration
- Protect admin routes with flexible auth middleware
- Container-based layout system for admin pages
- Configurable logging middleware with verbosity levels (0-3)

## Non-Goals (Future Considerations)

- Multi-factor authentication (MFA)
- OAuth/SAML integration
- Role-based access control (RBAC) - simple admin/non-admin only
- Password reset flow - Phase 2
- Rate limiting - separate spec
- CSS styling - focus on HTML structure first

## Architecture

### Route Grouping Pattern

Admin routes are organized into a logical group with shared middleware:

```typescript
// src/routes.ts
import { Router } from '../lib/router';
import { adminRoutes } from '../lib/admin/routes';

export function registerRoutes(router: Router): void {
  // ... existing routes ...
  
  // Admin routes (drop-in from library)
  router.group('/admin', adminRoutes);
}
```

The `group()` method:
- Prefixes all routes in the group with `/admin`
- Applies group-specific middleware automatically
- Keeps route definitions organized and maintainable

### Service Container Pattern

**Key Change**: Container moved to `src/container.ts` so users can modify it.

Pluggable services registered via DI container:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             Service Container                    â”‚
â”‚  (src/container.ts) â† User can modify            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ session    â†’ { store: SessionStore }          â”‚
â”‚  â€¢ admin      â†’ { layout: ComponentType }        â”‚
â”‚  â€¢ logging    â†’ { verbosity: number }            â”‚
â”‚  â€¢ search     â†’ SearchConfig (future)            â”‚
â”‚  â€¢ seo        â†’ SEOConfig (future)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–²
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ config/        â”‚   â”‚ lib/auth/      â”‚
â”‚ session.ts     â”‚   â”‚ session.ts     â”‚
â”‚ (user config)  â”‚   â”‚ (uses container)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Users configure services in `config/` directory:

```typescript
// config/session.ts
import { register } from '../src/container';
import { MemorySessionStore } from '../lib/auth/stores/memory';

register('session', () => ({
  store: new MemorySessionStore(),
}));
```

### Authentication Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User visits    â”‚
â”‚  /admin/*       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      No       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Auth middleware   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚  Custom redirect â”‚
â”‚  checks session    â”‚               â”‚  or /admin/login â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ Yes
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Admin handler     â”‚
â”‚  executes          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Login Flow:**
1. User visits `/admin/login` (GET)
2. Form rendered with username/password fields
3. User submits credentials (POST `/admin/login`)
4. Server validates credentials
5. On success: Set session cookie, redirect to `/admin/dashboard`
6. On failure: Re-render form with error message

**Logout Flow:**
1. User submits logout form (POST `/admin/logout`)
2. Server destroys session
3. Redirect to `/admin/login`

**Note**: Logout is a POST request because it changes server state (destroys session). This follows REST principles and prevents CSRF via GET links.

**Protected Routes:**
1. User visits `/admin/dashboard` (or any admin route)
2. Auth middleware checks for valid session
3. Valid session â†’ proceed to handler
4. Invalid/missing session â†’ execute configured response (default: redirect to `/admin/login`)

### Layout System via Container

```typescript
// Container holds services, not config

// Session service
register('session', () => ({
  store: new MemorySessionStore(),
}));

// Logging config
set('logging', { verbosity: 2 });

// Admin config with layout
set('admin', {
  layout: AdminLayout,
});
```

**Benefits:**
- âœ… Cleaner API: `resolve('session')` instead of `resolve('session.config')`
- âœ… More intuitive naming
- âœ… Consistent with future additions
- âœ… Less typing, clearer intent

### Logging System via Container

Logging configuration stored in container, set at server startup:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  src/server.ts                           â”‚
â”‚  1. Parse CLI flags (-v, -vv, -vvv)      â”‚
â”‚  2. Set 'logging' in container           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  logger() middleware                     â”‚
â”‚  1. Reads 'logging' from container       â”‚
â”‚  2. Returns appropriate middleware        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Verbosity Levels:**
- `0` (default): Silent - no request logging
- `1` (`-v`): Basic - method, path, status, duration
- `2` (`-vv`): Detailed - adds query params, selected headers
- `3` (`-vvv`): Debug - adds request/response bodies (sanitized)

### Layout System via Container

**Key Innovation**: Layout stored in container, set by `adminRoutes()`, retrieved automatically by `ui()`.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  adminRoutes() function                  â”‚
â”‚  1. Registers 'admin' in container       â”‚
â”‚  2. Registers all admin routes           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Admin Handlers (login, dashboard, etc.) â”‚
â”‚  Call ui(<Component />) with no params   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ui() helper                             â”‚
â”‚  1. Checks for explicit layout option    â”‚
â”‚  2. Falls back to 'admin' from container â”‚
â”‚  3. Falls back to default layout         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits:**
- âœ… No context passing to handlers
- âœ… Layout configured once in `adminRoutes()`
- âœ… Can still override per-handler if needed
- âœ… Clean separation of concerns

## Container Registration Order

**Critical**: Services must be registered in the container before they're used. Here's the startup sequence:

### 1. Runtime Config (src/server.ts)
Set immediate runtime configuration:
```typescript
set('logging', { verbosity });  // From CLI args
```

### 2. Import Config Files (src/server.ts)
Import config files which register services:
```typescript
import '../config/session';  // Calls register('session', ...)
import '../config/admin';     // Calls set('admin', ...)
```

### 3. Register Routes (src/server.ts)
After all config is loaded:
```typescript
const router = new Router();
registerRoutes(router);  // Calls router.group('/admin', adminRoutes)
```

### Container Contents After Startup

| Key       | Type       | Set By            | Used By                      |
|-----------|------------|-------------------|------------------------------|
| `logging` | `set()`    | src/server.ts     | src/middleware/logging.ts    |
| `session` | `register()` | config/session.ts | lib/auth/session.ts        |
| `admin`   | `set()`    | config/admin.ts   | lib/router/react/response.tsx|

**Key Points:**
- `logging` is set immediately in server.ts (runtime config)
- `session` is registered lazily in config/session.ts (factory pattern)
- `admin` is set in config/admin.ts (static config)
- All config happens **before** routes are registered
- Library code **reads from** container (resolve/has) but doesn't **set config** during route registration

## Implementation Details

### 1. Route Grouping System (lib/router/index.ts)

Add a `group()` method to the Router class with simplified RouteGroup:

```typescript
// lib/router/index.ts (addition)

export class Router {
  // ... existing methods ...
  
  /**
   * Register a group of routes with a common prefix and middleware
   * 
   * @example
   * ```ts
   * router.group('/admin', (group) => {
   *   group.get('/dashboard', dashboardHandler);
   *   group.get('/users', usersHandler);
   * }, [authMiddleware]);
   * ```
   */
  group(
    prefix: string,
    callback: (group: RouteGroup) => void,
    middleware: Middleware[] = []
  ): this {
    const group = new RouteGroup(this, prefix, middleware);
    callback(group);
    return this;
  }
}

/**
 * Route group builder
 * Proxies all method calls to router with prefix and middleware
 */
export class RouteGroup {
  constructor(
    private router: Router,
    private prefix: string,
    private middleware: Middleware[]
  ) {}
  
  /**
   * Proxy any HTTP method to the router with prefix and middleware
   */
  private route(
    method: 'get' | 'post' | 'put' | 'patch' | 'delete',
    pattern: string,
    handler: RouteHandler | HandlerImport,
    additionalMiddleware: Middleware[] = []
  ): this {
    this.router[method](
      this.prefix + pattern,
      handler,
      [...this.middleware, ...additionalMiddleware]
    );
    return this;
  }
  
  get(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('get', pattern, handler, middleware);
  }
  
  post(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('post', pattern, handler, middleware);
  }
  
  put(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('put', pattern, handler, middleware);
  }
  
  patch(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('patch', pattern, handler, middleware);
  }
  
  delete(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('delete', pattern, handler, middleware);
  }
}

// Export for use in lib/admin/routes.ts
export type { RouteGroup };
```

**Design Note**: RouteGroup uses a private `route()` method that proxies to the router, eliminating code duplication while maintaining a clean API.

### 2. Service Container (src/container.ts)

**Moved to src/** so users can modify it:

```typescript
// src/container.ts

/**
 * Service container for dependency injection
 * Supports lazy initialization and singleton pattern
 * 
 * Services are registered once (usually in config/) and resolved everywhere.
 * This pattern enables pluggable backends for session, search, SEO, layouts, etc.
 */
class Container {
  private services = new Map<string, any>();
  private factories = new Map<string, () => any>();

  /**
   * Register a service factory
   * Factory is called once on first get()
   */
  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }

  /**
   * Register a service instance directly
   */
  set<T>(name: string, instance: T): void {
    this.services.set(name, instance);
  }

  /**
   * Get a service instance
   * Initializes from factory if not already created
   */
  get<T>(name: string): T {
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Service "${name}" not registered. Did you forget to configure it in config/?`);
    }

    const instance = factory();
    this.services.set(name, instance);
    return instance;
  }

  /**
   * Check if a service is registered
   */
  has(name: string): boolean {
    return this.services.has(name) || this.factories.has(name);
  }

  /**
   * Clear all services (useful for testing)
   */
  clear(): void {
    this.services.clear();
    this.factories.clear();
  }
}

// Global service container
export const container = new Container();

/**
 * Helper to register services with type safety
 */
export function register<T>(name: string, factory: () => T): void {
  container.register(name, factory);
}

/**
 * Helper to resolve services with type safety
 */
export function resolve<T>(name: string): T {
  return container.get<T>(name);
}

/**
 * Helper to set service instances directly
 */
export function set<T>(name: string, instance: T): void {
  container.set(name, instance);
}

/**
 * Helper to check if service is registered
 */
export function has(name: string): boolean {
  return container.has(name);
}
```

### 3. Admin Configuration (config/admin.ts)

Admin panel configuration:

```typescript
// config/admin.ts

import { set } from '../src/container';
import { AdminLayout } from '../lib/admin/ui/AdminLayout';

/**
 * Admin panel configuration
 * 
 * Configure the admin layout and other admin settings here.
 * This file is imported early in server startup to ensure
 * the admin config is available when routes are registered.
 */

set('admin', {
  layout: AdminLayout,
});

// Alternative: Use a custom layout
// import { CustomAdminLayout } from '../src/ui/layouts/admin';
// set('admin', {
//   layout: CustomAdminLayout,
// });
```

### 4. Session Configuration (config/session.ts)

User-facing configuration file:

```typescript
// config/session.ts

import { MemorySessionStore } from '../lib/auth/stores/memory';
import { register } from '../src/container';

/**
 * Session storage configuration
 * 
 * Change this file to configure session backend.
 * Default: In-memory storage for local development.
 */

// Development: In-memory storage
register('session', () => ({
  store: new MemorySessionStore(),
}));

// Production examples (uncomment and configure as needed):

// Redis:
// import { RedisSessionStore } from '../lib/auth/stores/redis';
// import Redis from 'ioredis';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new RedisSessionStore(new Redis(process.env.REDIS_URL!)),
//   }));
// }

// Cloudflare Workers KV:
// import { KVSessionStore } from '../lib/auth/stores/kv';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new KVSessionStore(env.SESSION_STORE),
//   }));
// }

// Cloudflare D1:
// import { D1SessionStore } from '../lib/auth/stores/d1';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new D1SessionStore(env.DB),
//   }));
// }
```

### 5. Session Management (lib/auth/session.ts)

Session management using service container:

```typescript
// lib/auth/session.ts

import { resolve } from '../../src/container';

export interface Session {
  id: string;
  userId: string;
  createdAt: number;
  expiresAt: number;
}

/**
 * Session store interface
 * Implement this for different storage backends (memory, Redis, D1, KV)
 */
export interface SessionStore {
  get(sessionId: string): Promise<Session | null>;
  set(session: Session): Promise<void>;
  delete(sessionId: string): Promise<void>;
}

/**
 * Session configuration
 */
export interface SessionConfig {
  store: SessionStore;
}

/**
 * Get the configured session store from container
 */
function getSessionStore(): SessionStore {
  const config = resolve<SessionConfig>('session');
  return config.store;
}

/**
 * Create a new session for a user
 */
export async function createSession(userId: string): Promise<Session> {
  const id = crypto.randomUUID();
  const now = Date.now();
  const session: Session = {
    id,
    userId,
    createdAt: now,
    expiresAt: now + (7 * 24 * 60 * 60 * 1000), // 7 days
  };
  
  await getSessionStore().set(session);
  return session;
}

/**
 * Get session by ID
 */
export async function getSession(sessionId: string): Promise<Session | null> {
  return getSessionStore().get(sessionId);
}

/**
 * Delete a session (logout)
 */
export async function deleteSession(sessionId: string): Promise<void> {
  return getSessionStore().delete(sessionId);
}

/**
 * Get session cookie from request
 */
export async function getSessionFromRequest(request: Request): Promise<Session | null> {
  const cookie = request.headers.get('cookie');
  if (!cookie) return null;
  
  const sessionId = cookie
    .split(';')
    .find(c => c.trim().startsWith('session='))
    ?.split('=')[1];
  
  if (!sessionId) return null;
  
  return getSession(sessionId);
}

/**
 * Create session cookie header
 */
export function createSessionCookie(session: Session): string {
  return `session=${session.id}; HttpOnly; SameSite=Lax; Path=/; Max-Age=${60 * 60 * 24 * 7}`;
}

/**
 * Create logout cookie header (expires immediately)
 */
export function createLogoutCookie(): string {
  return 'session=; HttpOnly; SameSite=Lax; Path=/; Max-Age=0';
}
```

**Security Notes:**
- `HttpOnly` prevents JavaScript access
- `SameSite=Lax` protects against CSRF  
- `Secure` flag should be added in production (HTTPS only)
- SessionStore interface allows swapping storage backends without code changes
- Service container pattern enables clean dependency management

### 6. Memory Session Store (lib/auth/stores/memory.ts)

In-memory implementation:

```typescript
// lib/auth/stores/memory.ts

import type { SessionStore, Session } from '../session';

/**
 * In-memory session store (for local development)
 * 
 * WARNING: NOT suitable for production
 * - Sessions lost on server restart
 * - No multi-instance support
 * - No persistence
 * 
 * Use Redis/D1/KV for production.
 */
export class MemorySessionStore implements SessionStore {
  private sessions = new Map<string, Session>();

  async get(sessionId: string): Promise<Session | null> {
    const session = this.sessions.get(sessionId);
    
    if (!session) return null;
    
    // Check expiration
    if (session.expiresAt < Date.now()) {
      await this.delete(sessionId);
      return null;
    }
    
    return session;
  }

  async set(session: Session): Promise<void> {
    this.sessions.set(session.id, session);
  }

  async delete(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
  }
}
```

### 7. Redis Session Store (lib/auth/stores/redis.ts)

Production-ready Redis implementation:

```typescript
// lib/auth/stores/redis.ts

import type { SessionStore, Session } from '../session';
import type { Redis } from 'ioredis';

/**
 * Redis session store (production ready)
 * 
 * Features:
 * - Automatic expiration via TTL
 * - Multi-instance support
 * - Persistence
 * - High performance
 */
export class RedisSessionStore implements SessionStore {
  constructor(private redis: Redis) {}

  async get(sessionId: string): Promise<Session | null> {
    const data = await this.redis.get(`session:${sessionId}`);
    if (!data) return null;
    
    const session = JSON.parse(data) as Session;
    
    // Check expiration (redundant with TTL but safer)
    if (session.expiresAt < Date.now()) {
      await this.delete(sessionId);
      return null;
    }
    
    return session;
  }

  async set(session: Session): Promise<void> {
    const ttl = Math.floor((session.expiresAt - Date.now()) / 1000);
    await this.redis.setex(
      `session:${session.id}`,
      ttl,
      JSON.stringify(session)
    );
  }

  async delete(sessionId: string): Promise<void> {
    await this.redis.del(`session:${sessionId}`);
  }
}
```

### 8. Authentication Middleware (lib/auth/middleware.ts)

Flexible auth middleware with configurable responses:

```typescript
// lib/auth/middleware.ts

import type { Middleware } from '../router/types';
import { redirect } from '../router/response';
import { getSessionFromRequest } from './session';

/**
 * Options for requireAuth middleware
 */
export interface AuthOptions {
  /**
   * Custom response when authentication fails
   * Default: redirect to /admin/login with return URL
   */
  onUnauthorized?: (request: Request) => Response | Promise<Response>;
}

/**
 * Require authentication
 * 
 * @example
 * ```ts
 * // Default: redirect to login
 * requireAuth()
 * 
 * // Custom: return JSON error
 * requireAuth({
 *   onUnauthorized: () => json({ error: 'Unauthorized' }, 401)
 * })
 * 
 * // Custom: redirect to custom page
 * requireAuth({
 *   onUnauthorized: () => redirect('/access-denied')
 * })
 * ```
 */
export function requireAuth(options: AuthOptions = {}): Middleware {
  return async (request, context, next) => {
    const session = await getSessionFromRequest(request);
    
    if (!session) {
      // Use custom unauthorized handler or default redirect
      if (options.onUnauthorized) {
        return options.onUnauthorized(request);
      }
      
      // Default: redirect to login with return URL
      const url = new URL(request.url);
      const returnTo = encodeURIComponent(url.pathname);
      return redirect(`/admin/login?return=${returnTo}`);
    }
    
    // Add session to context for handlers
    context.session = session;
    
    return next();
  };
}

/**
 * Redirect if already authenticated
 * Used on login page to prevent logged-in users from seeing it
 */
export function redirectIfAuth(redirectTo: string = '/admin/dashboard'): Middleware {
  return async (request, context, next) => {
    const session = await getSessionFromRequest(request);
    
    if (session) {
      return redirect(redirectTo);
    }
    
    return next();
  };
}
```

**Design Note**: The `requireAuth()` middleware accepts an `options` object with an `onUnauthorized` callback, allowing users to customize the response when authentication fails.

### 9. Admin Layout Component (lib/admin/ui/AdminLayout.tsx)

Simple layout wrapper (no CSS):

```typescript
// lib/admin/ui/AdminLayout.tsx

import type { ReactNode } from 'react';
import { Helmet } from 'react-helmet-async';

interface AdminLayoutProps {
  children: ReactNode;
}

export function AdminLayout({ children }: AdminLayoutProps) {
  return (
    <>
      <Helmet>
        <meta charSet="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="robots" content="noindex, nofollow" />
      </Helmet>
      <main>
        {children}
      </main>
    </>
  );
}
```

### 10. Admin Route Definitions (lib/admin/routes.ts)

Admin routes define all admin panel endpoints:

```typescript
// lib/admin/routes.ts

import type { RouteGroup } from '../router';
import { requireAuth, redirectIfAuth } from '../auth/middleware';

/**
 * Register admin routes
 * 
 * This function defines all CMS admin routes.
 * Handlers live in lib/admin/handlers/ making the admin panel a drop-in feature.
 * 
 * Note: Admin config (including layout) must be set in config/admin.ts
 * before routes are registered.
 */
export function adminRoutes(group: RouteGroup): void {
  // Public routes (login)
  group.get('/login', import('./handlers/login'), [redirectIfAuth()]);
  group.post('/login', import('./handlers/authenticate'));
  
  // Logout (POST because it changes state)
  group.post('/logout', import('./handlers/logout'), [requireAuth()]);
  
  // Protected routes
  group.get('/dashboard', import('./handlers/dashboard'), [requireAuth()]);
  
  // Future routes:
  // group.get('/schemas', import('./handlers/schemas/list'), [requireAuth()]);
  // group.get('/schemas/create', import('./handlers/schemas/create'), [requireAuth()]);
  // group.post('/schemas', import('./handlers/schemas/create'), [requireAuth()]);
  // group.get('/content', import('./handlers/content/list'), [requireAuth()]);
}
```

**Design Note**: Admin routes and handlers are part of the library, making the admin panel a drop-in feature. Admin config (including layout) is set in `config/admin.ts`, keeping all configuration in one place.

### 11. Updated ui() Helper (lib/router/react/response.tsx)

Check container for admin config:

```typescript
// lib/router/react/response.tsx

import { has, resolve } from '../../../src/container';
import type { ReactElement, ComponentType } from 'react';
import { renderToString } from 'react-dom/server';
import { HelmetProvider } from 'react-helmet-async';

export interface UiOptions {
  status?: number;
  rootId?: string;
  layout?: ComponentType<{ children: ReactElement }>;  // Explicit layout override
}

/**
 * Admin configuration
 */
interface AdminConfig {
  layout: ComponentType<{ children: ReactElement }>;
}

/**
 * Server-side render a React component to HTML
 * 
 * Layout priority:
 * 1. Explicit layout option
 * 2. admin config from container (if exists)
 * 3. Default layout from src/ui/layouts/default
 */
export async function ui(
  component: ReactElement,
  options: UiOptions = {}
): Promise<Response> {
  const {
    status = 200,
    rootId = 'root',
    layout,
  } = options;
  
  // Layout priority
  let LayoutComponent: ComponentType<{ children: ReactElement }>;
  
  if (layout) {
    // 1. Explicit layout
    LayoutComponent = layout;
  } else if (has('admin')) {
    // 2. Admin layout from container
    const adminConfig = resolve<AdminConfig>('admin');
    LayoutComponent = adminConfig.layout;
  } else {
    // 3. Default layout
    const defaultLayout = await import('../../../src/ui/layouts/default');
    LayoutComponent = defaultLayout.DefaultLayout;
  }
  
  // Render with layout
  const helmetContext = {};
  
  const html = renderToString(
    <HelmetProvider context={helmetContext}>
      <LayoutComponent>
        {component}
      </LayoutComponent>
    </HelmetProvider>
  );
  
  const { helmet } = helmetContext as any;
  
  const document = `<!DOCTYPE html>
<html ${helmet.htmlAttributes.toString()}>
<head>
  ${helmet.title.toString()}
  ${helmet.meta.toString()}
  ${helmet.link.toString()}
</head>
<body ${helmet.bodyAttributes.toString()}>
  <div id="${rootId}">${html}</div>
</body>
</html>`;

  return new Response(document, {
    status,
    headers: {
      'Content-Type': 'text/html; charset=utf-8',
    },
  });
}
```

### 12. Login Handler (lib/admin/handlers/login.tsx)

Server-side rendered login form (no CSS):

```typescript
// lib/admin/handlers/login.tsx

import type { RequestContext } from '../../router/types';
import { ui } from '../../router/react/response';
import { LoginForm } from '../ui/LoginForm';

/**
 * GET /admin/login
 * Show login form
 * Layout automatically used from container
 */
export default function login(request: Request, context: RequestContext): Promise<Response> {
  const error = context.query.get('error');
  const returnTo = context.query.get('return') || '/admin/dashboard';
  
  return ui(<LoginForm error={error} returnTo={returnTo} />);
}
```

### 13. Login Form Component (lib/admin/ui/LoginForm.tsx)

React component with native HTML form (no CSS):

```typescript
// lib/admin/ui/LoginForm.tsx

import { Helmet } from 'react-helmet-async';

interface LoginFormProps {
  error?: string | null;
  returnTo?: string;
}

export function LoginForm({ error, returnTo }: LoginFormProps) {
  return (
    <>
      <Helmet>
        <title>Admin Login - Project Conduit</title>
      </Helmet>
      
      <div>
        <header>
          <h1>Project Conduit</h1>
          <p>Admin Login</p>
        </header>
        
        {error && (
          <div role="alert">
            {decodeURIComponent(error)}
          </div>
        )}
        
        <form method="POST" action="/admin/login">
          <input type="hidden" name="return" value={returnTo || '/admin/dashboard'} />
          
          <div>
            <label htmlFor="username">Username</label>
            <input
              type="text"
              id="username"
              name="username"
              required
              autoFocus
              autoComplete="username"
            />
          </div>
          
          <div>
            <label htmlFor="password">Password</label>
            <input
              type="password"
              id="password"
              name="password"
              required
              autoComplete="current-password"
            />
          </div>
          
          <button type="submit">Log In</button>
        </form>
        
        <footer>
          <p>Default credentials: <code>admin</code> / <code>admin</code></p>
        </footer>
      </div>
    </>
  );
}
```

### 14. Authentication Handler (lib/admin/handlers/authenticate.ts)

Process login using native FormData:

```typescript
// lib/admin/handlers/authenticate.ts

import type { RequestContext } from '../../router/types';
import { redirect } from '../../router/response';
import { createSession, createSessionCookie } from '../../auth/session';

// TODO: Move to database or environment variables
const ADMIN_CREDENTIALS = {
  username: 'admin',
  password: 'admin', // In production: hash with argon2
};

/**
 * POST /admin/login
 * Authenticate user and create session
 * Uses native FormData from HTML form submission
 */
export default async function authenticate(
  request: Request,
  context: RequestContext
): Promise<Response> {
  // Parse form data (native web platform FormData API)
  const formData = await request.formData();
  const username = formData.get('username')?.toString();
  const password = formData.get('password')?.toString();
  const returnTo = formData.get('return')?.toString() || '/admin/dashboard';
  
  // Validate credentials
  if (!username || !password) {
    return redirect('/admin/login?error=' + encodeURIComponent('Username and password required'));
  }
  
  // Check credentials (replace with database lookup in production)
  if (username !== ADMIN_CREDENTIALS.username || password !== ADMIN_CREDENTIALS.password) {
    return redirect('/admin/login?error=' + encodeURIComponent('Invalid credentials'));
  }
  
  // Create session
  const session = await createSession(username);
  
  // Set cookie and redirect
  const response = redirect(returnTo);
  response.headers.append('Set-Cookie', createSessionCookie(session));
  
  return response;
}
```

**Why Native Forms?**
- No JavaScript required for login to work
- Progressive enhancement ready
- Works with password managers
- Standard browser behavior (no custom fetch code)
- Accessible by default

### 15. Dashboard Handler (lib/admin/handlers/dashboard.tsx)

Protected dashboard route:

```typescript
// lib/admin/handlers/dashboard.tsx

import type { RequestContext } from '../../router/types';
import { ui } from '../../router/react/response';
import { Dashboard } from '../ui/Dashboard';

/**
 * GET /admin/dashboard
 * Show admin dashboard (requires auth)
 * Layout automatically used from container
 */
export default function dashboard(request: Request, context: RequestContext): Promise<Response> {
  // Session available in context.session (set by auth middleware)
  return ui(<Dashboard session={context.session!} />);
}
```

### 16. Dashboard Component (lib/admin/ui/Dashboard.tsx)

Admin dashboard with logout form (no CSS):

```typescript
// lib/admin/ui/Dashboard.tsx

import { Helmet } from 'react-helmet-async';
import type { Session } from '../../auth/session';

interface DashboardProps {
  session: Session;
}

export function Dashboard({ session }: DashboardProps) {
  return (
    <>
      <Helmet>
        <title>Dashboard - Project Conduit Admin</title>
      </Helmet>
      
      <div>
        <header>
          <h1>Dashboard</h1>
          <div>
            <span>Welcome, {session.userId}</span>
            <form method="POST" action="/admin/logout" style={{ display: 'inline' }}>
              <button type="submit">Logout</button>
            </form>
          </div>
        </header>
        
        <main>
          <p>Welcome to the Project Conduit admin panel.</p>
          
          <nav>
            <ul>
              <li><a href="/admin/schemas">Schemas</a> - Manage content types</li>
              <li><a href="/admin/content">Content</a> - Create and edit content</li>
              <li><a href="/admin/events">Events</a> - View event log</li>
            </ul>
          </nav>
        </main>
      </div>
    </>
  );
}
```

### 17. Logout Handler (lib/admin/handlers/logout.ts)

Logout via POST:

```typescript
// lib/admin/handlers/logout.ts

import type { RequestContext } from '../../router/types';
import { redirect } from '../../router/response';
import { deleteSession, getSessionFromRequest, createLogoutCookie } from '../../auth/session';

/**
 * POST /admin/logout
 * Destroy session and redirect to login
 * POST because it changes server state (destroys session)
 */
export default async function logout(
  request: Request,
  context: RequestContext
): Promise<Response> {
  const session = await getSessionFromRequest(request);
  
  if (session) {
    await deleteSession(session.id);
  }
  
  const response = redirect('/admin/login');
  response.headers.append('Set-Cookie', createLogoutCookie());
  
  return response;
}
```

**Why POST for logout?**
- Logout changes server state (destroys session)
- GET requests should be safe/idempotent per HTTP spec
- Prevents CSRF via malicious links (e.g., `<img src="/admin/logout">`)
- Standard practice for state-changing operations

### 18. Logging Configuration (src/logging-config.ts)

Interface for logging configuration:

```typescript
// src/logging-config.ts

export interface LoggingConfig {
  verbosity: number;
}

export const defaultLoggingConfig: LoggingConfig = {
  verbosity: 0, // Silent by default
};
```

### 19. Logging Middleware (src/middleware/logging.ts)

Reads logging config from container:

```typescript
// src/middleware/logging.ts

import type { Middleware } from '../../lib/router/types';
import { resolve, has } from '../container';

/**
 * Logging configuration
 */
interface LoggingConfig {
  verbosity: number;
}

/**
 * Request/response logger with configurable verbosity
 * Reads verbosity from container (set in server.ts)
 * 
 * Verbosity levels:
 * 0 - Silent (no logs)
 * 1 - Basic (method, path, status, duration)
 * 2 - Detailed (adds query params, selected headers)
 * 3 - Debug (adds sanitized request/response bodies)
 */
export function logger(): Middleware {
  // Get logging config from container
  const config = has('logging') 
    ? resolve<LoggingConfig>('logging')
    : { verbosity: 1 };
  
  const { verbosity } = config;
  
  if (verbosity === 0) {
    // Silent mode
    return async (request, context, next) => next();
  }
  
  return async (request, context, next) => {
    const start = Date.now();
    const { method } = request;
    const url = new URL(request.url);
    
    // Capture request body if needed (level 3)
    let requestBody: any = null;
    if (verbosity >= 3 && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      try {
        const cloned = request.clone();
        const contentType = request.headers.get('content-type');
        
        if (contentType?.includes('application/json')) {
          requestBody = await cloned.json();
        } else if (contentType?.includes('application/x-www-form-urlencoded') || 
                   contentType?.includes('multipart/form-data')) {
          const formData = await cloned.formData();
          requestBody = Object.fromEntries(formData.entries());
        }
      } catch (e) {
        // Ignore body parsing errors
      }
    }
    
    // Execute request
    const response = await next();
    const duration = Date.now() - start;
    
    // Build log output based on verbosity
    const logParts: string[] = [];
    
    // Level 1: Basic
    logParts.push(`${method} ${url.pathname}`);
    logParts.push(`${response.status}`);
    logParts.push(`${duration}ms`);
    
    // Level 2: Detailed
    if (verbosity >= 2) {
      if (url.search) {
        logParts.push(`query=${url.search}`);
      }
      
      // Request headers (selected)
      const reqHeaders: string[] = [];
      ['content-type', 'user-agent', 'authorization'].forEach(header => {
        const value = request.headers.get(header);
        if (value) {
          const displayValue = header === 'authorization' ? '[REDACTED]' : value;
          reqHeaders.push(`${header}: ${displayValue}`);
        }
      });
      if (reqHeaders.length > 0) {
        logParts.push(`req_headers={${reqHeaders.join(', ')}}`);
      }
      
      // Response headers (selected)
      const resHeaders: string[] = [];
      ['content-type', 'set-cookie', 'location'].forEach(header => {
        const value = response.headers.get(header);
        if (value) {
          const displayValue = header === 'set-cookie' 
            ? value.split(';')[0] + '; ...' 
            : value;
          resHeaders.push(`${header}: ${displayValue}`);
        }
      });
      if (resHeaders.length > 0) {
        logParts.push(`res_headers={${resHeaders.join(', ')}}`);
      }
    }
    
    // Level 3: Debug
    if (verbosity >= 3) {
      if (requestBody) {
        const sanitized = sanitizeBody(requestBody);
        logParts.push(`req_body=${JSON.stringify(sanitized)}`);
      }
      
      // Response body (JSON only, truncated)
      const contentType = response.headers.get('content-type');
      if (contentType?.includes('application/json')) {
        try {
          const cloned = response.clone();
          const body = await cloned.json();
          const sanitized = sanitizeBody(body);
          const truncated = JSON.stringify(sanitized).slice(0, 500);
          logParts.push(`res_body=${truncated}${truncated.length === 500 ? '...' : ''}`);
        } catch (e) {
          // Ignore
        }
      }
    }
    
    console.log(logParts.join(' '));
    return response;
  };
}

/**
 * Sanitize bodies to redact sensitive fields
 */
function sanitizeBody(body: any): any {
  if (typeof body !== 'object' || body === null) {
    return body;
  }
  
  const sensitiveFields = ['password', 'token', 'secret', 'apiKey', 'api_key'];
  const sanitized: any = Array.isArray(body) ? [] : {};
  
  for (const [key, value] of Object.entries(body)) {
    if (sensitiveFields.some(field => key.toLowerCase().includes(field.toLowerCase()))) {
      sanitized[key] = '[REDACTED]';
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeBody(value);
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}
```

## Route Registration

Users register admin routes in their `src/routes.ts`:

```typescript
// src/routes.ts

import { Router } from '../lib/router';
import { adminRoutes } from '../lib/admin/routes';
import { cors } from './middleware/cors';
import { logger } from './middleware/logging';

export function registerRoutes(router: Router): void {
  // Global middleware
  router.use(cors());
  router.use(logger());  // No params needed - reads from container

  // Serve static files
  router.static('public');

  // Homepage
  router.get('/', import('./handlers/home'));

  // Admin panel (drop-in from library)
  router.group('/admin', adminRoutes);
  
  // Future user routes:
  // router.get('/posts', import('./handlers/posts/list'));
  // router.get('/posts/:slug', import('./handlers/posts/show'));
}
```

**Note**: Users don't need to implement admin handlers - they're included in the library. Just register the route group and the admin panel works.

## Server Initialization

Initialize services in `src/server.ts`:

```typescript
// src/server.ts

import { set } from './container';

// Parse CLI verbosity
const verbosity = process.argv.reduce((count, arg) => {
  if (arg === '-v') return count + 1;
  if (arg === '-vv') return count + 2;
  if (arg === '-vvv') return count + 3;
  return count;
}, 0);

// Configure logging in container
set('logging', { verbosity });

// Import config files to register services
import '../config/session';
import '../config/admin';
// import '../config/search'; (future)
// import '../config/seo'; (future)

import { Router } from '../lib/router';
import { createBunServer } from '../lib/adapters/bun';
import { registerRoutes } from './routes';

const router = new Router();
registerRoutes(router);

const server = createBunServer(router, {
  port: Number(process.env.PORT) || 3000,
  hostname: process.env.HOSTNAME || '127.0.0.1',
  development: process.env.NODE_ENV !== 'production',
});

console.log(`ğŸš€ Server running at http://${server.hostname}:${server.port}`);
if (verbosity > 0) {
  console.log(`ğŸ“Š Logging verbosity: ${verbosity}`);
}
```

**Key Points**: 
- Set logging config in container first (runtime config)
- Import all config files before registering routes
- Config files register services in container (session, admin, etc.)
- Routes are registered last, after all config is loaded

### CLI Usage for Logging

```bash
# Silent (no request logging)
bun src/server.ts

# Basic logging (method, path, status, duration)
bun src/server.ts -v

# Detailed logging (adds query params, headers)
bun src/server.ts -vv

# Debug logging (adds sanitized request/response bodies)
bun src/server.ts -vvv
```

## Directory Structure

```
/
â”œâ”€â”€ lib/                           # ğŸ“¦ VENDOR LIBRARY CODE
â”‚   â”œâ”€â”€ admin/                     # Admin panel (drop-in feature)
â”‚   â”‚   â”œâ”€â”€ routes.ts             # Admin route definitions
â”‚   â”‚   â”œâ”€â”€ handlers/             # Admin handlers (included in library)
â”‚   â”‚   â”‚   â”œâ”€â”€ login.tsx         # Login form (GET)
â”‚   â”‚   â”‚   â”œâ”€â”€ authenticate.ts   # Login processing (POST)
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard.tsx     # Dashboard (GET)
â”‚   â”‚   â”‚   â””â”€â”€ logout.ts         # Logout (POST)
â”‚   â”‚   â””â”€â”€ ui/                   # Admin UI components (no CSS)
â”‚   â”‚       â”œâ”€â”€ AdminLayout.tsx   # Admin layout component
â”‚   â”‚       â”œâ”€â”€ LoginForm.tsx     # Login form (no CSS)
â”‚   â”‚       â””â”€â”€ Dashboard.tsx     # Dashboard (no CSS)
â”‚   â”‚
â”‚   â”œâ”€â”€ auth/                      # Authentication utilities
â”‚   â”‚   â”œâ”€â”€ middleware.ts         # Auth middleware (requireAuth, redirectIfAuth)
â”‚   â”‚   â”œâ”€â”€ session.ts            # Session management (uses container)
â”‚   â”‚   â””â”€â”€ stores/               # Session store implementations
â”‚   â”‚       â”œâ”€â”€ memory.ts         # In-memory store (dev)
â”‚   â”‚       â””â”€â”€ redis.ts          # Redis store (production)
â”‚   â”‚
â”‚   â””â”€â”€ router/
â”‚       â”œâ”€â”€ react/
â”‚       â”‚   â””â”€â”€ response.tsx      # ğŸ”§ Checks container for admin config
â”‚       â””â”€â”€ index.ts              # ğŸ”§ Add group() method
â”‚
â”œâ”€â”€ src/                           # ğŸ  USER IMPLEMENTATION
â”‚   â”œâ”€â”€ container.ts               # ğŸ†• DI container (moved from lib/)
â”‚   â”œâ”€â”€ logging-config.ts          # ğŸ†• Logging config interface
â”‚   â”‚
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â””â”€â”€ home.tsx              # User handlers only
â”‚   â”‚
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ cors.ts
â”‚   â”‚   â””â”€â”€ logging.ts            # ğŸ†• Reads logging from container
â”‚   â”‚
â”‚   â”œâ”€â”€ routes.ts                 # ğŸ”§ Register admin routes
â”‚   â””â”€â”€ server.ts                 # ğŸ”§ Set logging, import all configs
â”‚
â”œâ”€â”€ config/                        # ğŸ†• USER CONFIGURATION
â”‚   â”œâ”€â”€ admin.ts                  # ğŸ†• Admin config (layout)
â”‚   â”œâ”€â”€ session.ts                # Session storage config
â”‚   # search.ts                   # Search provider config (future)
â”‚   # seo.ts                      # SEO provider config (future)
```

**Key Changes from Original:**
- Container moved to `src/container.ts` (user can modify)
- Admin handlers and UI in `lib/` (drop-in)
- **Admin config in `config/admin.ts`** (NEW - for consistency)
- New logging middleware with verbosity levels
- No CSS in initial implementation

## Type Definitions

Update `lib/router/types.ts` to support sessions in context:

```typescript
// lib/router/types.ts (addition)

import type { Session } from '../auth/session';

export interface RequestContext {
  params: Record<string, string>;
  query: URLSearchParams;
  session?: Session;  // Added by auth middleware
  [key: string]: unknown;
}
```

## Future Service Configuration Examples

The container pattern extends to other pluggable services:

```typescript
// config/search.ts (future)
import type { SearchProvider } from '../lib/search';
import { register } from '../src/container';

// Default: Simple in-memory search
import { MemorySearchProvider } from '../lib/search/providers/memory';
register('search', () => ({
  provider: new MemorySearchProvider(),
}));

// Production: Elasticsearch
// import { ElasticsearchProvider } from '../lib/search/providers/elasticsearch';
// register('search', () => ({
//   provider: new ElasticsearchProvider({
//     node: process.env.ELASTICSEARCH_URL,
//   }),
// }));
```

```typescript
// config/seo.ts (future)
import type { SEOProvider } from '../lib/seo';
import { register } from '../src/container';

// Default: Basic meta tags
import { BasicSEOProvider } from '../lib/seo/providers/basic';
register('seo', () => ({
  provider: new BasicSEOProvider(),
}));

// Advanced: With Open Graph, Twitter Cards, JSON-LD
// import { AdvancedSEOProvider } from '../lib/seo/providers/advanced';
// register('seo', () => ({
//   provider: new AdvancedSEOProvider({
//     siteName: 'My Site',
//     twitterHandle: '@mysite',
//   }),
// }));
```

## Security Considerations

### Phase 1 (This Spec)
- HTTP-only cookies prevent XSS attacks
- SameSite=Lax prevents CSRF
- In-memory sessions (dev only)
- Hardcoded credentials (dev only)
- Sensitive field redaction in logs

### Phase 2 (Future)
- Hash passwords with argon2
- Store credentials in database
- Rate limiting on login endpoint
- Add `Secure` flag to cookies (HTTPS only)
- Swap to Redis/D1/KV session store for production
- Add session cleanup job (remove expired sessions)

**Note**: POST logout eliminates need for CSRF tokens on logout. Native form submission provides CSRF protection for login.

### Phase 3 (Future)
- Two-factor authentication (TOTP)
- OAuth providers (Google, GitHub)
- Audit logging
- Password reset flow
- Account lockout after failed attempts

## Testing Strategy

### Unit Tests

```typescript
// src/__tests__/container.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { container } from '../container';

describe('Service Container', () => {
  beforeEach(() => {
    container.clear();
  });

  it('registers and resolves services', () => {
    container.register('test', () => ({ value: 42 }));
    const service = container.get('test');
    expect(service.value).toBe(42);
  });

  it('throws for unregistered services', () => {
    expect(() => container.get('unknown')).toThrow();
  });

  it('creates singletons', () => {
    container.register('test', () => ({ value: Math.random() }));
    const first = container.get('test');
    const second = container.get('test');
    expect(first).toBe(second);
  });
});
```

```typescript
// lib/auth/__tests__/session.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { createSession, getSession, deleteSession } from '../session';
import { container } from '../../../src/container';
import { MemorySessionStore } from '../stores/memory';

describe('Session management', () => {
  beforeEach(() => {
    container.clear();
    container.register('session', () => ({
      store: new MemorySessionStore(),
    }));
  });

  it('creates a new session', async () => {
    const session = await createSession('admin');
    expect(session.userId).toBe('admin');
    expect(session.id).toBeDefined();
  });
  
  it('retrieves existing session', async () => {
    const session = await createSession('admin');
    const retrieved = await getSession(session.id);
    expect(retrieved).toEqual(session);
  });
  
  it('deletes session', async () => {
    const session = await createSession('admin');
    await deleteSession(session.id);
    expect(await getSession(session.id)).toBeNull();
  });
});
```

### Integration Tests

```typescript
// lib/admin/__tests__/admin-auth.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { Router } from '../../router';
import { container } from '../../../src/container';
import { MemorySessionStore } from '../../auth/stores/memory';
import { adminRoutes } from '../routes';

describe('Admin authentication', () => {
  let router: Router;
  
  beforeEach(() => {
    container.clear();
    container.register('session', () => ({
      store: new MemorySessionStore(),
    }));
    
    router = new Router();
    router.group('/admin', adminRoutes);
  });
  
  it('GET /admin/login returns login form', async () => {
    const request = new Request('http://localhost:3000/admin/login');
    const response = await router.handle(request);
    
    expect(response.status).toBe(200);
    expect(response.headers.get('content-type')).toContain('text/html');
  });
  
  it('POST /admin/login with valid credentials creates session', async () => {
    const formData = new FormData();
    formData.append('username', 'admin');
    formData.append('password', 'admin');
    
    const request = new Request('http://localhost:3000/admin/login', {
      method: 'POST',
      body: formData,
    });
    
    const response = await router.handle(request);
    
    expect(response.status).toBe(302);
    expect(response.headers.get('location')).toBe('/admin/dashboard');
    expect(response.headers.get('set-cookie')).toContain('session=');
  });
  
  it('GET /admin/dashboard without session redirects to login', async () => {
    const request = new Request('http://localhost:3000/admin/dashboard');
    const response = await router.handle(request);
    
    expect(response.status).toBe(302);
    expect(response.headers.get('location')).toContain('/admin/login');
  });
});
```

## Implementation Phases

### Phase 1: Core Infrastructure (Priority)
- [ ] Move container to `src/container.ts` with `set()` helper
- [ ] Add `group()` method to Router class with RouteGroup proxy pattern
- [ ] Create `config/` directory structure
- [ ] Create `lib/auth/session.ts` with container integration
- [ ] Create `lib/auth/stores/memory.ts`
- [ ] Create `config/session.ts` with default configuration
- [ ] Write tests for container and session management

### Phase 2: Authentication Middleware (Priority)
- [ ] Create `lib/auth/middleware.ts` with flexible `requireAuth()`
- [ ] Add `onUnauthorized` option to auth middleware
- [ ] Update types to include `Session` in `RequestContext`
- [ ] Write tests for auth middleware

### Phase 3: Admin Panel UI (Priority)
- [ ] Create `lib/admin/` directory structure
- [ ] Create admin layout component (`lib/admin/ui/AdminLayout.tsx`) - no CSS
- [ ] Create login handler (`lib/admin/handlers/login.tsx`)
- [ ] Create LoginForm component (`lib/admin/ui/LoginForm.tsx`) - no CSS
- [ ] Create authenticate handler (`lib/admin/handlers/authenticate.ts`)
- [ ] Create dashboard handler (`lib/admin/handlers/dashboard.tsx`)
- [ ] Create Dashboard component (`lib/admin/ui/Dashboard.tsx`) - no CSS
- [ ] Create logout handler (`lib/admin/handlers/logout.ts`)
- [ ] Test login flow end-to-end with native FormData

### Phase 4: Layout System
- [ ] Create `config/admin.ts` that sets admin config in container
- [ ] Update `lib/admin/routes.ts` to remove container manipulation
- [ ] Update `ui()` helper to check container for admin config
- [ ] Test layout system with admin routes
- [ ] Verify single-line drop-in works

### Phase 5: Logging System
- [ ] Create `src/logging-config.ts` interface
- [ ] Create `src/middleware/logging.ts` with verbosity levels
- [ ] Update `src/server.ts` to parse CLI flags and set logging config
- [ ] Test logging at all verbosity levels (0-3)
- [ ] Verify sensitive field redaction

### Phase 6: Integration & Documentation
- [ ] Update example `src/routes.ts` to register admin routes
- [ ] Write integration tests for complete admin flow
- [ ] Write integration tests for logging
- [ ] Document admin panel usage
- [ ] Document logging CLI flags

## Success Criteria

- [ ] Service container works with lazy initialization
- [ ] Container lives in `src/container.ts` (user can modify)
- [ ] `config/session.ts` allows easy backend swapping
- [ ] `/admin/login` renders a login form using native HTML (no CSS)
- [ ] Form submission with valid credentials creates a session
- [ ] Form submission with invalid credentials shows error
- [ ] Session cookie is HTTP-only and SameSite
- [ ] `/admin/dashboard` redirects to login when not authenticated
- [ ] `/admin/dashboard` shows dashboard when authenticated (no CSS)
- [ ] POST `/admin/logout` destroys session and redirects to login
- [ ] `router.group()` method uses proxy pattern (no code duplication)
- [ ] Auth middleware accepts `onUnauthorized` option
- [ ] Admin handlers live in `lib/admin/` (drop-in feature)
- [ ] `adminRoutes()` sets `admin` config in container
- [ ] `ui()` automatically uses admin layout from `admin` config
- [ ] Handlers don't need to pass layout to `ui()`
- [ ] Logging middleware reads config from `logging` in container
- [ ] CLI flags (-v, -vv, -vvv) control logging verbosity
- [ ] Sensitive fields are redacted in logs
- [ ] All tests pass
- [ ] Native FormData used throughout (no JSON APIs for forms)
- [ ] Single line drop-in: `router.group('/admin', adminRoutes)`

## Open Questions

1. **Password hashing**: Use bcrypt or argon2? (Defer to Phase 2 - argon2 recommended)
2. **Remember me**: Should we add "remember me" functionality? (Phase 3)
3. **Password reset**: Email-based or admin-managed? (Separate spec)
4. **CSS approach**: When we add CSS, use scoped prefix or CSS modules? (Future decision)
5. **Log rotation**: How should we handle log files if we switch from console.log? (Future)

## References

- MDN Web Docs: HTTP Cookies - https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
- MDN: FormData API - https://developer.mozilla.org/en-US/docs/Web/API/FormData
- OWASP Session Management Cheat Sheet - https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
- Web.dev: SameSite cookies explained - https://web.dev/samesite-cookies-explained/
- HTTP Spec: Safe Methods - https://www.rfc-editor.org/rfc/rfc9110.html#name-safe-methods
- Dependency Injection Pattern - https://en.wikipedia.org/wiki/Dependency_injection

---

**Status**: Draft - Merged with 2025120803
**Key Improvements**: 
- âœ… Merged authentication + layout + logging into single spec
- âœ… Container moved to `src/` for user modification
- âœ… Clean naming: `session`, `admin`, `logging` (no `.config` suffix)
- âœ… Config objects in container (not raw services)
- âœ… No CSS in initial implementation (focus on HTML structure)
- âœ… Container-based layout system (no prop drilling)
- âœ… Configurable logging with verbosity levels
- âœ… Single-line drop-in admin panel
- âœ… Clean separation of concerns

**Next Steps**: Review merged spec, then implement Phase 1
