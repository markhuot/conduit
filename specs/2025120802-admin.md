# Admin Authentication & Infrastructure Specification

**Spec ID**: 2025120802  
**Created**: 2025-12-08  
**Updated**: 2025-12-10 (Implementation Complete)  
**Status**: ‚úÖ Complete  
**Phase**: Admin Foundation  
**Dependencies**: 2025120801-routing.md

## Overview

This spec defines the complete admin system for Project Conduit including authentication, layout management, and session handling. The admin panel is a **drop-in library feature** with handlers and UI included in `lib/`, ready to use without custom implementation.

**Key Features:**
1. Simple, secure login flow with session management
2. AsyncLocalStorage-based context system for request-scoped data
3. Layout middleware system using request context
4. Single-line drop-in: `router.group('/admin', adminRoutes)`

**Implementation Status:** ‚úÖ Complete - All phases implemented and working

## Design Principles

1. **Simple & Secure**: Start with basic authentication, plan for extensions
2. **Route Grouping**: Organize admin routes together for clarity
3. **Drop-in Feature**: Admin panel lives in `lib/` as a reusable component
4. **Service Container**: Pluggable services via DI container pattern (moved to `src/`)
5. **Session-Based**: Use HTTP-only cookies with pluggable storage backends
6. **Platform Native**: Embrace HTML forms and standard web patterns
7. **Framework Agnostic**: Auth system works with any frontend framework
8. **No Prop Drilling**: Container pattern eliminates passing config around

## Goals

- Implement `/admin/login` route with simple login form (no CSS initially)
- Create route grouping system (`router.group('/admin', ...)`)
- Build drop-in admin panel in `lib/admin/`
- Establish service container for pluggable backends (in `src/container.ts`)
- Create `config/` directory for user configuration
- Protect admin routes with flexible auth middleware
- Container-based layout system for admin pages
- Configurable logging middleware with verbosity levels (0-3)

## Non-Goals (Future Considerations)

- Multi-factor authentication (MFA)
- OAuth/SAML integration
- Role-based access control (RBAC) - simple admin/non-admin only
- Password reset flow - Phase 2
- Rate limiting - separate spec
- CSS styling - focus on HTML structure first

## Architecture

### Route Grouping Pattern

Admin routes are organized into a logical group with shared middleware:

```typescript
// src/routes.ts
import { Router } from '../lib/router';
import { adminRoutes } from '../lib/admin/routes';

export function registerRoutes(router: Router): void {
  // ... existing routes ...
  
  // Admin routes (drop-in from library)
  router.group('/admin', adminRoutes);
}
```

The `group()` method:
- Prefixes all routes in the group with `/admin`
- Applies group-specific middleware automatically
- Keeps route definitions organized and maintainable

### Service Container Pattern

**Key Change**: Container moved to `src/container.ts` so users can modify it.

Pluggable services registered via DI container:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             Service Container                    ‚îÇ
‚îÇ  (src/container.ts) ‚Üê User can modify            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ session    ‚Üí { store: SessionStore }          ‚îÇ
‚îÇ  ‚Ä¢ admin      ‚Üí { layout: ComponentType }        ‚îÇ
‚îÇ  ‚Ä¢ logging    ‚Üí { verbosity: number }            ‚îÇ
‚îÇ  ‚Ä¢ search     ‚Üí SearchConfig (future)            ‚îÇ
‚îÇ  ‚Ä¢ seo        ‚Üí SEOConfig (future)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚ñ≤
                    ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ config/        ‚îÇ   ‚îÇ lib/auth/      ‚îÇ
‚îÇ session.ts     ‚îÇ   ‚îÇ session.ts     ‚îÇ
‚îÇ (user config)  ‚îÇ   ‚îÇ (uses container)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Users configure services in `config/` directory:

```typescript
// config/session.ts
import { register } from '../src/container';
import { MemorySessionStore } from '../lib/auth/stores/memory';

register('session', () => ({
  store: new MemorySessionStore(),
}));
```

### Authentication Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User visits    ‚îÇ
‚îÇ  /admin/*       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      No       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Auth middleware   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ  Custom redirect ‚îÇ
‚îÇ  checks session    ‚îÇ               ‚îÇ  or /admin/login ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ Yes
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Admin handler     ‚îÇ
‚îÇ  executes          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Login Flow:**
1. User visits `/admin/login` (GET)
2. Form rendered with username/password fields
3. User submits credentials (POST `/admin/login`)
4. Server validates credentials
5. On success: Set session cookie, redirect to `/admin/dashboard`
6. On failure: Re-render form with error message

**Logout Flow:**
1. User submits logout form (POST `/admin/logout`)
2. Server destroys session
3. Redirect to `/admin/login`

**Note**: Logout is a POST request because it changes server state (destroys session). This follows REST principles and prevents CSRF via GET links.

**Protected Routes:**
1. User visits `/admin/dashboard` (or any admin route)
2. Auth middleware checks for valid session
3. Valid session ‚Üí proceed to handler
4. Invalid/missing session ‚Üí execute configured response (default: redirect to `/admin/login`)

### Layout System via Container

```typescript
// Container holds services, not config

// Session service
register('session', () => ({
  store: new MemorySessionStore(),
}));

// Logging config
set('logging', { verbosity: 2 });

// Admin config with layout
set('admin', {
  layout: AdminLayout,
});
```

**Benefits:**
- ‚úÖ Cleaner API: `resolve('session')` instead of `resolve('session.config')`
- ‚úÖ More intuitive naming
- ‚úÖ Consistent with future additions
- ‚úÖ Less typing, clearer intent

## Implementation Details

### 1. Route Grouping System (lib/router/index.ts)

Add a `group()` method to the Router class with RouteGroup that supports group-level middleware via `use()`:

```typescript
// lib/router/index.ts (addition)

export class Router {
  // ... existing methods ...
  
  /**
   * Register a group of routes with a common prefix and middleware
   * 
   * @example
   * ```ts
   * router.group('/admin', (group) => {
   *   group.use(withLayout(AdminLayout));  // Group-level middleware
   *   group.get('/dashboard', dashboardHandler);
   *   group.get('/users', usersHandler);
   * }, [authMiddleware]);
   * ```
   */
  group(
    prefix: string,
    callback: (group: RouteGroup) => void,
    middleware: Middleware[] = []
  ): this {
    const group = new RouteGroup(this, prefix, middleware);
    callback(group);
    return this;
  }
}

/**
 * Route group builder
 * Proxies all method calls to router with prefix and middleware
 */
export class RouteGroup {
  private groupMiddleware: Middleware[] = [];
  
  constructor(
    private router: Router,
    private prefix: string,
    private middleware: Middleware[]
  ) {}
  
  /**
   * Add middleware that applies to all routes in this group
   * Called after group-level middleware but before route-specific middleware
   */
  use(middleware: Middleware): this {
    this.groupMiddleware.push(middleware);
    return this;
  }
  
  /**
   * Proxy any HTTP method to the router with prefix and middleware
   */
  private route(
    method: 'get' | 'post' | 'put' | 'patch' | 'delete',
    pattern: string,
    handler: RouteHandler | HandlerImport,
    additionalMiddleware: Middleware[] = []
  ): this {
    this.router[method](
      this.prefix + pattern,
      handler,
      [...this.middleware, ...this.groupMiddleware, ...additionalMiddleware]
    );
    return this;
  }
  
  get(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('get', pattern, handler, middleware);
  }
  
  post(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('post', pattern, handler, middleware);
  }
  
  put(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('put', pattern, handler, middleware);
  }
  
  patch(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('patch', pattern, handler, middleware);
  }
  
  delete(pattern: string, handler: RouteHandler | HandlerImport, middleware: Middleware[] = []): this {
    return this.route('delete', pattern, handler, middleware);
  }
}

// Export for use in lib/admin/routes.ts
export type { RouteGroup };
```

**Design Note**: RouteGroup uses a private `route()` method that proxies to the router. The `use()` method allows adding group-level middleware that applies to all routes in the group.

### 2. Service Container (src/container.ts)

**Moved to src/** so users can modify it:

```typescript
// src/container.ts

/**
 * Service container for dependency injection
 * Supports lazy initialization and singleton pattern
 * 
 * Services are registered once (usually in config/) and resolved everywhere.
 * This pattern enables pluggable backends for session, search, SEO, layouts, etc.
 */
class Container {
  private services = new Map<string, any>();
  private factories = new Map<string, () => any>();

  /**
   * Register a service factory
   * Factory is called once on first get()
   */
  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }

  /**
   * Register a service instance directly
   */
  set<T>(name: string, instance: T): void {
    this.services.set(name, instance);
  }

  /**
   * Get a service instance
   * Initializes from factory if not already created
   */
  get<T>(name: string): T {
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Service "${name}" not registered. Did you forget to configure it in config/?`);
    }

    const instance = factory();
    this.services.set(name, instance);
    return instance;
  }

  /**
   * Check if a service is registered
   */
  has(name: string): boolean {
    return this.services.has(name) || this.factories.has(name);
  }

  /**
   * Clear all services (useful for testing)
   */
  clear(): void {
    this.services.clear();
    this.factories.clear();
  }
}

// Global service container
export const container = new Container();

/**
 * Helper to register services with type safety
 */
export function register<T>(name: string, factory: () => T): void {
  container.register(name, factory);
}

/**
 * Helper to resolve services with type safety
 */
export function resolve<T>(name: string): T {
  return container.get<T>(name);
}

/**
 * Helper to set service instances directly
 */
export function set<T>(name: string, instance: T): void {
  container.set(name, instance);
}

/**
 * Helper to check if service is registered
 */
export function has(name: string): boolean {
  return container.has(name);
}
```

### 3. AsyncLocalStorage Context System (lib/router/context.ts)

**New Addition**: Request context management using Node.js AsyncLocalStorage:

```typescript
// lib/router/context.ts

import { AsyncLocalStorage } from 'async_hooks';
import type { RequestContext } from './types';

/**
 * Async local storage for request context
 * Maintains request-scoped context across async operations
 * Each request gets its own isolated context, even with concurrent requests
 */
const requestContextStorage = new AsyncLocalStorage<RequestContext>();

/**
 * Get current request context from async local storage
 * Available anywhere within the request handling chain
 * 
 * @throws Error if called outside a request handler
 */
export function getRequestContext(): RequestContext {
  const ctx = requestContextStorage.getStore();
  if (!ctx) {
    throw new Error(
      'Request context not available. Are you calling this outside a request handler?'
    );
  }
  return ctx;
}

/**
 * Run callback with request context stored in async local storage
 * Used internally by the router
 * All async operations within the callback will have access to this context
 * 
 * @internal
 */
export async function runWithContext<T>(ctx: RequestContext, fn: () => T | Promise<T>): Promise<T> {
  return await requestContextStorage.run(ctx, fn);
}
```

**Key Benefits:**
- ‚úÖ No prop drilling - context available anywhere via `getRequestContext()`
- ‚úÖ Request isolation - each concurrent request has its own context
- ‚úÖ Works with async operations - context preserved across `await`
- ‚úÖ Type-safe access to session, layout, params, etc.

### 4. Layout Middleware (lib/router/react/middleware.ts)

**New Addition**: Middleware to set layout in request context:

```typescript
// lib/router/react/middleware.ts

import type { Middleware } from '../types';
import type { ComponentType, ReactElement } from 'react';

/**
 * Set layout for all routes using this middleware
 * 
 * The layout is stored in request context and automatically
 * picked up by the ui() helper via AsyncLocalStorage.
 */
export function withLayout(
  layout: ComponentType<{ children: ReactElement }>
): Middleware {
  return async (ctx, next) => {
    ctx.layout = layout;
    return next();
  };
}
```

**Usage Example:**
```typescript
// In adminRoutes()
group.use(withLayout(AdminLayout));  // All routes in group use this layout
```

### 5. Admin Configuration (REMOVED)

**Note**: The `config/admin.ts` file is **NOT needed** in the final implementation. Layout configuration is handled entirely through middleware (`withLayout()`) rather than the container pattern. This simplifies the architecture.

### 6. Session Configuration (config/session.ts)

User-facing configuration file:

```typescript
// config/session.ts

import { MemorySessionStore } from '../lib/auth/stores/memory';
import { register } from '../src/container';

/**
 * Session storage configuration
 * 
 * Change this file to configure session backend.
 * Default: In-memory storage for local development.
 */

// Development: In-memory storage
register('session', () => ({
  store: new MemorySessionStore(),
}));

// Production examples (uncomment and configure as needed):

// Redis:
// import { RedisSessionStore } from '../lib/auth/stores/redis';
// import Redis from 'ioredis';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new RedisSessionStore(new Redis(process.env.REDIS_URL!)),
//   }));
// }

// Cloudflare Workers KV:
// import { KVSessionStore } from '../lib/auth/stores/kv';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new KVSessionStore(env.SESSION_STORE),
//   }));
// }

// Cloudflare D1:
// import { D1SessionStore } from '../lib/auth/stores/d1';
//
// if (process.env.NODE_ENV === 'production') {
//   register('session', () => ({
//     store: new D1SessionStore(env.DB),
//   }));
// }
```

### 6. Session Configuration (config/session.ts)

Session management using service container:

```typescript
### 7. Session Management (lib/session/index.ts)

Session management using service container:

```typescript
// lib/session/index.ts

import { resolve } from '../../src/container';

export interface Session {
  id: string;
  userId: string;
  createdAt: number;
  expiresAt: number;
}

/**
 * Session store interface
 * Implement this for different storage backends (memory, Redis, D1, KV)
 */
export interface SessionStore {
  get(sessionId: string): Promise<Session | null>;
  set(session: Session): Promise<void>;
  delete(sessionId: string): Promise<void>;
}

/**
 * Session configuration
 */
export interface SessionConfig {
  store: SessionStore;
}

/**
 * Get the configured session store from container
 */
function getSessionStore(): SessionStore {
  const config = resolve<SessionConfig>('session');
  return config.store;
}

/**
 * Create a new session for a user
 */
export async function createSession(userId: string): Promise<Session> {
  const id = crypto.randomUUID();
  const now = Date.now();
  const session: Session = {
    id,
    userId,
    createdAt: now,
    expiresAt: now + (7 * 24 * 60 * 60 * 1000), // 7 days
  };
  
  await getSessionStore().set(session);
  return session;
}

/**
 * Get session by ID
 */
export async function getSession(sessionId: string): Promise<Session | null> {
  return getSessionStore().get(sessionId);
}

/**
 * Delete a session (logout)
 */
export async function deleteSession(sessionId: string): Promise<void> {
  return getSessionStore().delete(sessionId);
}

/**
 * Get session cookie from request
 */
export async function getSessionFromRequest(request: Request): Promise<Session | null> {
  const cookie = request.headers.get('cookie');
  if (!cookie) return null;
  
  const sessionId = cookie
    .split(';')
    .find(c => c.trim().startsWith('session='))
    ?.split('=')[1];
  
  if (!sessionId) return null;
  
  return getSession(sessionId);
}

/**
 * Create session cookie header
 */
export function createSessionCookie(session: Session): string {
  return `session=${session.id}; HttpOnly; SameSite=Lax; Path=/; Max-Age=${60 * 60 * 24 * 7}`;
}

/**
 * Create logout cookie header (expires immediately)
 */
export function createLogoutCookie(): string {
  return 'session=; HttpOnly; SameSite=Lax; Path=/; Max-Age=0';
}
```

**Security Notes:**
- `HttpOnly` prevents JavaScript access
- `SameSite=Lax` protects against CSRF  
- `Secure` flag should be added in production (HTTPS only)
- SessionStore interface allows swapping storage backends without code changes
- Service container pattern enables clean dependency management

### 8. Memory Session Store (lib/session/stores/memory.ts)

In-memory implementation:

```typescript
```typescript
// lib/session/stores/memory.ts

import type { SessionStore, Session } from '../session';

/**
 * In-memory session store (for local development)
 * 
 * WARNING: NOT suitable for production
 * - Sessions lost on server restart
 * - No multi-instance support
 * - No persistence
 * 
 * Use Redis/D1/KV for production.
 */
export class MemorySessionStore implements SessionStore {
  private sessions = new Map<string, Session>();

  async get(sessionId: string): Promise<Session | null> {
    const session = this.sessions.get(sessionId);
    
    if (!session) return null;
    
    // Check expiration
    if (session.expiresAt < Date.now()) {
      await this.delete(sessionId);
      return null;
    }
    
    return session;
  }

  async set(session: Session): Promise<void> {
    this.sessions.set(session.id, session);
  }

  async delete(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
  }
}
```

### 9. Authentication Middleware (lib/auth/middleware.ts)

Production-ready Redis implementation:

```typescript
// lib/auth/stores/redis.ts

import type { SessionStore, Session } from '../session';
import type { Redis } from 'ioredis';

/**
 * Redis session store (production ready)
 * 
 * Features:
 * - Automatic expiration via TTL
 * - Multi-instance support
 * - Persistence
 * - High performance
 */
export class RedisSessionStore implements SessionStore {
  constructor(private redis: Redis) {}

  async get(sessionId: string): Promise<Session | null> {
    const data = await this.redis.get(`session:${sessionId}`);
    if (!data) return null;
    
    const session = JSON.parse(data) as Session;
    
    // Check expiration (redundant with TTL but safer)
    if (session.expiresAt < Date.now()) {
      await this.delete(sessionId);
      return null;
    }
    
    return session;
  }

  async set(session: Session): Promise<void> {
    const ttl = Math.floor((session.expiresAt - Date.now()) / 1000);
    await this.redis.setex(
      `session:${session.id}`,
      ttl,
      JSON.stringify(session)
    );
  }

  async delete(sessionId: string): Promise<void> {
    await this.redis.del(`session:${sessionId}`);
  }
}
```

### 8. Authentication Middleware (lib/auth/middleware.ts)

Flexible auth middleware with configurable responses:

```typescript
// lib/auth/middleware.ts

import type { Middleware } from '../router/types';
import { redirect } from '../router/response';
import { getSessionFromRequest } from '../session';

/**
 * Options for requireAuth middleware
 */
export interface AuthOptions {
  /**
   * Custom response when authentication fails
   * Default: redirect to /admin/login with return URL
   */
  onUnauthorized?: (request: Request) => Response | Promise<Response>;
}

/**
 * Require authentication
 * 
 * @example
 * ```ts
 * // Default: redirect to login
 * requireAuth()
 * 
 * // Custom: return JSON error
 * requireAuth({
 *   onUnauthorized: () => json({ error: 'Unauthorized' }, 401)
 * })
 * 
 * // Custom: redirect to custom page
 * requireAuth({
 *   onUnauthorized: () => redirect('/access-denied')
 * })
 * ```
 */
export function requireAuth(options: AuthOptions = {}): Middleware {
  return async (request, context, next) => {
    const session = await getSessionFromRequest(request);
    
    if (!session) {
      // Use custom unauthorized handler or default redirect
      if (options.onUnauthorized) {
        return options.onUnauthorized(request);
      }
      
      // Default: redirect to login with return URL
      const url = new URL(request.url);
      const returnTo = encodeURIComponent(url.pathname);
      return redirect(`/admin/login?return=${returnTo}`);
    }
    
    // Add session to context for handlers
    context.session = session;
    
    return next();
  };
}

/**
 * Redirect if already authenticated
 * Used on login page to prevent logged-in users from seeing it
 */
export function redirectIfAuth(redirectTo: string = '/admin/dashboard'): Middleware {
  return async (request, context, next) => {
    const session = await getSessionFromRequest(request);
    
    if (session) {
      return redirect(redirectTo);
    }
    
    return next();
  };
}
```

**Design Note**: The `requireAuth()` middleware accepts an `options` object with an `onUnauthorized` callback, allowing users to customize the response when authentication fails.

### 10. Admin Layout Component (lib/admin/ui/AdminLayout.tsx)

Simple layout wrapper (no CSS):

```typescript
// lib/admin/ui/AdminLayout.tsx

import type { ReactNode } from 'react';
import { Helmet } from 'react-helmet-async';

interface AdminLayoutProps {
  children: ReactNode;
}

export function AdminLayout({ children }: AdminLayoutProps) {
  return (
    <>
      <Helmet>
        <meta charSet="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="robots" content="noindex, nofollow" />
      </Helmet>
      <main>
        {children}
      </main>
    </>
  );
}
```

### 11. Admin Route Definitions (lib/admin/routes.ts)

Admin routes define all admin panel endpoints:

```typescript
// lib/admin/routes.ts

import type { RouteGroup } from '../router';
import { requireAuth, redirectIfAuth } from '../auth/middleware';
import { withLayout } from '../router/react/middleware';
import { AdminLayout } from './ui/AdminLayout';

/**
 * Register admin routes
 * 
 * This function defines all CMS admin routes.
 * Handlers live in lib/admin/handlers/ making the admin panel a drop-in feature.
 * 
 * The admin layout is set via middleware and automatically picked up by ui()
 * through AsyncLocalStorage - no need to pass it to handlers.
 */
export function adminRoutes(group: RouteGroup): void {
  // Apply admin layout to all routes in this group
  group.use(withLayout(AdminLayout));
  
  // Public routes (login)
  group.get('/login', import('./handlers/login'), [redirectIfAuth()]);
  group.post('/login', import('./handlers/authenticate'));
  
  // Logout (POST because it changes state)
  group.post('/logout', import('./handlers/logout'), [requireAuth()]);
  
  // Protected routes
  group.get('/dashboard', import('./handlers/dashboard'), [requireAuth()]);
  
  // Future routes:
  // group.get('/schemas', import('./handlers/schemas/list'), [requireAuth()]);
  // group.get('/schemas/create', import('./handlers/schemas/create'), [requireAuth()]);
  // group.post('/schemas', import('./handlers/schemas/create'), [requireAuth()]);
  // group.get('/content', import('./handlers/content/list'), [requireAuth()]);
}
```

**Design Note**: Admin routes and handlers are part of the library, making the admin panel a drop-in feature. Layout is set via `group.use(withLayout(AdminLayout))` which applies to all routes in the group.

### 12. Updated ui() Helper (lib/router/react/response.tsx)

Uses AsyncLocalStorage context for layout:

```typescript
// lib/router/react/response.tsx

import { renderToString } from 'react-dom/server';
import type { ReactElement, ComponentType } from 'react';
import { HelmetProvider } from 'react-helmet-async';
import { getRequestContext } from '../context';

export interface UiOptions {
  status?: number;
  rootId?: string;
  layout?: ComponentType<{ children: ReactElement }>;  // Explicit layout override
}

/**
 * Server-side render a React component to HTML
 * 
 * Layout priority:
 * 1. Explicit layout option passed to ui()
 * 2. Layout from request context (set by middleware via ctx.layout)
 * 3. Default layout from src/ui/layouts/default
 * 
 * The request context is automatically available via AsyncLocalStorage,
 * so handlers don't need to pass it around.
 */
export async function ui(
  component: ReactElement,
  options: UiOptions = {}
): Promise<Response> {
  const ctx = getRequestContext();  // Get context from AsyncLocalStorage
  const { status = 200, rootId = 'root', layout } = options;
  
  // Layout priority
  let LayoutComponent: ComponentType<{ children: ReactElement }>;
  
  if (layout) {
    // 1. Explicit layout option
    LayoutComponent = layout;
  } else if (ctx.layout) {
    // 2. Layout from request context (set by middleware)
    LayoutComponent = ctx.layout;
  } else {
    // 3. Default layout
    const defaultLayout = await import('../../../src/ui/layouts/default');
    LayoutComponent = defaultLayout.DefaultLayout;
  }
  
  // Render with layout
  const helmetContext = {};
  
  const html = renderToString(
    <HelmetProvider context={helmetContext}>
      <LayoutComponent>
        {component}
      </LayoutComponent>
    </HelmetProvider>
  );
  
  const { helmet } = helmetContext as any;
  
  const document = `<!DOCTYPE html>
<html ${helmet.htmlAttributes.toString()}>
<head>
  ${helmet.title.toString()}
  ${helmet.meta.toString()}
  ${helmet.link.toString()}
</head>
<body ${helmet.bodyAttributes.toString()}>
  <div id="${rootId}">${html}</div>
</body>
</html>`;

  return new Response(document, {
    status,
    headers: {
      'Content-Type': 'text/html; charset=utf-8',
    },
  });
}
```

### 13. Login Handler (lib/admin/handlers/login.tsx)

Server-side rendered login form (no CSS):

```typescript
// lib/admin/handlers/login.tsx

import type { RequestContext } from '../../router/types';
import { ui } from '../../router/react/response';
import { LoginForm } from '../ui/LoginForm';

/**
 * GET /admin/login
 * Show login form
 * Layout automatically used from request context (set by withLayout middleware)
 */
export default function login(request: Request, context: RequestContext): Promise<Response> {
  const error = context.query.get('error');
  const returnTo = context.query.get('return') || '/admin/dashboard';
  
  return ui(<LoginForm error={error} returnTo={returnTo} />);
}
```

### 14. Login Form Component (lib/admin/ui/LoginForm.tsx)

React component with native HTML form (no CSS):

```typescript
// lib/admin/ui/LoginForm.tsx

import { Helmet } from 'react-helmet-async';

interface LoginFormProps {
  error?: string | null;
  returnTo?: string;
}

export function LoginForm({ error, returnTo }: LoginFormProps) {
  return (
    <>
      <Helmet>
        <title>Admin Login - Project Conduit</title>
      </Helmet>
      
      <div>
        <header>
          <h1>Project Conduit</h1>
          <p>Admin Login</p>
        </header>
        
        {error && (
          <div role="alert">
            {decodeURIComponent(error)}
          </div>
        )}
        
        <form method="POST" action="/admin/login">
          <input type="hidden" name="return" value={returnTo || '/admin/dashboard'} />
          
          <div>
            <label htmlFor="username">Username</label>
            <input
              type="text"
              id="username"
              name="username"
              required
              autoFocus
              autoComplete="username"
            />
          </div>
          
          <div>
            <label htmlFor="password">Password</label>
            <input
              type="password"
              id="password"
              name="password"
              required
              autoComplete="current-password"
            />
          </div>
          
          <button type="submit">Log In</button>
        </form>
        
        <footer>
          <p>Default credentials: <code>admin</code> / <code>admin</code></p>
        </footer>
      </div>
    </>
  );
}
```

### 15. Authentication Handler (lib/admin/handlers/authenticate.ts)

Process login using native FormData:

```typescript
// lib/admin/handlers/authenticate.ts

import type { RequestContext } from '../../router/types';
import { redirect } from '../../router/response';
import { createSession, createSessionCookie } from '../../session';

// TODO: Move to database or environment variables
const ADMIN_CREDENTIALS = {
  username: 'admin',
  password: 'admin', // In production: hash with argon2
};

/**
 * POST /admin/login
 * Authenticate user and create session
 * Uses native FormData from HTML form submission
 */
export default async function authenticate(
  request: Request,
  context: RequestContext
): Promise<Response> {
  // Parse form data (native web platform FormData API)
  const formData = await request.formData();
  const username = formData.get('username')?.toString();
  const password = formData.get('password')?.toString();
  const returnTo = formData.get('return')?.toString() || '/admin/dashboard';
  
  // Validate credentials
  if (!username || !password) {
    return redirect('/admin/login?error=' + encodeURIComponent('Username and password required'));
  }
  
  // Check credentials (replace with database lookup in production)
  if (username !== ADMIN_CREDENTIALS.username || password !== ADMIN_CREDENTIALS.password) {
    return redirect('/admin/login?error=' + encodeURIComponent('Invalid credentials'));
  }
  
  // Create session
  const session = await createSession(username);
  
  // Set cookie and redirect
  const response = redirect(returnTo);
  response.headers.append('Set-Cookie', createSessionCookie(session));
  
  return response;
}
```

**Why Native Forms?**
- No JavaScript required for login to work
- Progressive enhancement ready
- Works with password managers
- Standard browser behavior (no custom fetch code)
- Accessible by default

### 16. Dashboard Handler (lib/admin/handlers/dashboard.tsx)

Protected dashboard route:

```typescript
// lib/admin/handlers/dashboard.tsx

import type { RequestContext } from '../../router/types';
import { ui } from '../../router/react/response';
import { Dashboard } from '../ui/Dashboard';

/**
 * GET /admin/dashboard
 * Show admin dashboard (requires auth)
 * Layout automatically used from request context (set by withLayout middleware)
 */
export default function dashboard(request: Request, context: RequestContext): Promise<Response> {
  // Session available in context.session (set by auth middleware)
  return ui(<Dashboard session={context.session!} />);
}
```

### 17. Dashboard Component (lib/admin/ui/Dashboard.tsx)

Admin dashboard with logout form (no CSS):

```typescript
// lib/admin/ui/Dashboard.tsx

import { Helmet } from 'react-helmet-async';
import type { Session } from '../../session';

interface DashboardProps {
  session: Session;
}

export function Dashboard({ session }: DashboardProps) {
  return (
    <>
      <Helmet>
        <title>Dashboard - Project Conduit Admin</title>
      </Helmet>
      
      <div>
        <header>
          <h1>Dashboard</h1>
          <div>
            <span>Welcome, {session.userId}</span>
            <form method="POST" action="/admin/logout" style={{ display: 'inline' }}>
              <button type="submit">Logout</button>
            </form>
          </div>
        </header>
        
        <main>
          <p>Welcome to the Project Conduit admin panel.</p>
          
          <nav>
            <ul>
              <li><a href="/admin/schemas">Schemas</a> - Manage content types</li>
              <li><a href="/admin/content">Content</a> - Create and edit content</li>
              <li><a href="/admin/events">Events</a> - View event log</li>
            </ul>
          </nav>
        </main>
      </div>
    </>
  );
}
```

### 18. Logout Handler (lib/admin/handlers/logout.ts)

Logout via POST:

```typescript
// lib/admin/handlers/logout.ts

import type { RequestContext } from '../../router/types';
import { redirect } from '../../router/response';
import { deleteSession, getSessionFromRequest, createLogoutCookie } from '../../session';

/**
 * POST /admin/logout
 * Destroy session and redirect to login
 * POST because it changes server state (destroys session)
 */
export default async function logout(
  request: Request,
  context: RequestContext
): Promise<Response> {
  const session = await getSessionFromRequest(request);
  
  if (session) {
    await deleteSession(session.id);
  }
  
  const response = redirect('/admin/login');
  response.headers.append('Set-Cookie', createLogoutCookie());
  
  return response;
}
```

**Why POST for logout?**
- Logout changes server state (destroys session)
- GET requests should be safe/idempotent per HTTP spec
- Prevents CSRF via malicious links (e.g., `<img src="/admin/logout">`)
- Standard practice for state-changing operations

## Route Registration

Users register admin routes in their `src/routes.ts`:

```typescript
// src/routes.ts

import { Router } from '../lib/router';
import { adminRoutes } from '../lib/admin/routes';
import { cors } from './middleware/cors';
import { simpleLogger } from './middleware/logging';

export function registerRoutes(router: Router): void {
  // Global middleware
  router.use(cors());
  router.use(simpleLogger());  // Simple request logger

  // Serve static files
  router.static('public');

  // Homepage
  router.get('/', import('./handlers/home'));

  // Admin panel (drop-in from library)
  router.group('/admin', adminRoutes);
  
  // Future user routes:
  // router.get('/posts', import('./handlers/posts/list'));
  // router.get('/posts/:slug', import('./handlers/posts/show'));
}
```

**Note**: Users don't need to implement admin handlers - they're included in the library. Just register the route group and the admin panel works.

## Server Initialization

Initialize services in `src/server.ts`:

```typescript
// src/server.ts

// Import config files to register services in container
// This must happen before routes are registered
import '../config/session';

import { Router } from '../lib/router';
import { createBunServer } from '../lib/adapters/bun';
import { registerRoutes } from './routes';

const router = new Router();
registerRoutes(router);

const server = createBunServer(router, {
  port: Number(process.env.PORT) || 3000,
  hostname: process.env.HOSTNAME || '127.0.0.1',
  development: process.env.NODE_ENV !== 'production',
});

console.log(`üöÄ Server running at http://${server.hostname}:${server.port}`);
```

**Key Points**: 
- Import all config files before registering routes
- Config files register services in container (session, etc.)
- Routes are registered last, after all config is loaded

## Directory Structure

```
/
‚îú‚îÄ‚îÄ lib/                           # üì¶ VENDOR LIBRARY CODE
‚îÇ   ‚îú‚îÄ‚îÄ admin/                     # Admin panel (drop-in feature)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.ts             # Admin route definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/             # Admin handlers (included in library)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx         # Login form (GET)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authenticate.ts   # Login processing (POST)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx     # Dashboard (GET)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logout.ts         # Logout (POST)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                   # Admin UI components (no CSS)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AdminLayout.tsx   # Admin layout component
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx     # Login form (no CSS)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Dashboard.tsx     # Dashboard (no CSS)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ integration.test.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ auth/                      # Authentication utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware.ts         # Auth middleware (requireAuth, redirectIfAuth)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ middleware.test.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ session/                   # Session management (uses container)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts              # Session management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores/               # Session store implementations
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory.ts         # In-memory store (dev)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.test.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ       ‚îú‚îÄ‚îÄ context.ts            # üÜï AsyncLocalStorage for request context
‚îÇ       ‚îú‚îÄ‚îÄ react/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ middleware.ts     # üÜï withLayout() middleware
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ response.tsx      # üîß Uses AsyncLocalStorage for layout
‚îÇ       ‚îú‚îÄ‚îÄ index.ts              # üîß Add group() method + RouteGroup
‚îÇ       ‚îî‚îÄ‚îÄ types.ts              # üîß Add session & layout to RequestContext
‚îÇ
‚îú‚îÄ‚îÄ src/                           # üè† USER IMPLEMENTATION
‚îÇ   ‚îú‚îÄ‚îÄ container.ts               # üÜï DI container (moved from lib/)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ container.test.ts     # Container tests
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ home.tsx              # User handlers only
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cors.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.ts            # Simple request logger
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routes.ts                 # üîß Register admin routes
‚îÇ   ‚îî‚îÄ‚îÄ server.ts                 # üîß Import config files
‚îÇ
‚îú‚îÄ‚îÄ config/                        # üÜï USER CONFIGURATION
‚îÇ   ‚îî‚îÄ‚îÄ session.ts                # Session storage config
```

**Key Changes:**
- AsyncLocalStorage context system in `lib/router/context.ts`
- Layout middleware in `lib/router/react/middleware.ts`
- Session code in `lib/session/` (not `lib/auth/`)
- Container in `src/container.ts` (user-modifiable)
- RouteGroup supports `use()` for group-level middleware
- No `config/admin.ts` needed - layout via middleware
- Tests included for core functionality

## Type Definitions

Update `lib/router/types.ts` to support sessions and layouts in context:

```typescript
// lib/router/types.ts (addition)

import type { Session } from '../session';
import type { ComponentType, ReactElement } from 'react';

export interface RequestContext {
  request: Request;
  params: Record<string, string>;
  query: URLSearchParams;
  url: URL;
  session?: Session;  // Added by auth middleware
  layout?: ComponentType<{ children: ReactElement }>;  // Added by layout middleware
  [key: string]: unknown;
}
```

## Future Service Configuration Examples

The container pattern extends to other pluggable services. Here are examples for future features:

```typescript
// config/search.ts (future)
import type { SearchProvider } from '../lib/search';
import { register } from '../src/container';

// Default: Simple in-memory search
import { MemorySearchProvider } from '../lib/search/providers/memory';
register('search', () => ({
  provider: new MemorySearchProvider(),
}));

// Production: Elasticsearch
// import { ElasticsearchProvider } from '../lib/search/providers/elasticsearch';
// register('search', () => ({
//   provider: new ElasticsearchProvider({
//     node: process.env.ELASTICSEARCH_URL,
//   }),
// }));
```

```typescript
// config/seo.ts (future)
import type { SEOProvider } from '../lib/seo';
import { register } from '../src/container';

// Default: Basic meta tags
import { BasicSEOProvider } from '../lib/seo/providers/basic';
register('seo', () => ({
  provider: new BasicSEOProvider(),
}));

// Advanced: With Open Graph, Twitter Cards, JSON-LD
// import { AdvancedSEOProvider } from '../lib/seo/providers/advanced';
// register('seo', () => ({
//   provider: new AdvancedSEOProvider({
//     siteName: 'My Site',
//     twitterHandle: '@mysite',
//   }),
// }));
```

## Security Considerations

### Phase 1 (This Spec)
- HTTP-only cookies prevent XSS attacks
- SameSite=Lax prevents CSRF
- In-memory sessions (dev only)
- Hardcoded credentials (dev only)
- Sensitive field redaction in logs

### Phase 2 (Future)
- Hash passwords with argon2
- Store credentials in database
- Rate limiting on login endpoint
- Add `Secure` flag to cookies (HTTPS only)
- Swap to Redis/D1/KV session store for production
- Add session cleanup job (remove expired sessions)

**Note**: POST logout eliminates need for CSRF tokens on logout. Native form submission provides CSRF protection for login.

### Phase 3 (Future)
- Two-factor authentication (TOTP)
- OAuth providers (Google, GitHub)
- Audit logging
- Password reset flow
- Account lockout after failed attempts

## Testing Strategy

### Unit Tests

```typescript
// src/__tests__/container.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { container } from '../container';

describe('Service Container', () => {
  beforeEach(() => {
    container.clear();
  });

  it('registers and resolves services', () => {
    container.register('test', () => ({ value: 42 }));
    const service = container.get('test');
    expect(service.value).toBe(42);
  });

  it('throws for unregistered services', () => {
    expect(() => container.get('unknown')).toThrow();
  });

  it('creates singletons', () => {
    container.register('test', () => ({ value: Math.random() }));
    const first = container.get('test');
    const second = container.get('test');
    expect(first).toBe(second);
  });
});
```

```typescript
// lib/auth/__tests__/session.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { createSession, getSession, deleteSession } from '../session';
import { container } from '../../../src/container';
import { MemorySessionStore } from '../stores/memory';

describe('Session management', () => {
  beforeEach(() => {
    container.clear();
    container.register('session', () => ({
      store: new MemorySessionStore(),
    }));
  });

  it('creates a new session', async () => {
    const session = await createSession('admin');
    expect(session.userId).toBe('admin');
    expect(session.id).toBeDefined();
  });
  
  it('retrieves existing session', async () => {
    const session = await createSession('admin');
    const retrieved = await getSession(session.id);
    expect(retrieved).toEqual(session);
  });
  
  it('deletes session', async () => {
    const session = await createSession('admin');
    await deleteSession(session.id);
    expect(await getSession(session.id)).toBeNull();
  });
});
```

### Integration Tests

```typescript
// lib/admin/__tests__/admin-auth.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { Router } from '../../router';
import { container } from '../../../src/container';
import { MemorySessionStore } from '../../auth/stores/memory';
import { adminRoutes } from '../routes';

describe('Admin authentication', () => {
  let router: Router;
  
  beforeEach(() => {
    container.clear();
    container.register('session', () => ({
      store: new MemorySessionStore(),
    }));
    
    router = new Router();
    router.group('/admin', adminRoutes);
  });
  
  it('GET /admin/login returns login form', async () => {
    const request = new Request('http://localhost:3000/admin/login');
    const response = await router.handle(request);
    
    expect(response.status).toBe(200);
    expect(response.headers.get('content-type')).toContain('text/html');
  });
  
  it('POST /admin/login with valid credentials creates session', async () => {
    const formData = new FormData();
    formData.append('username', 'admin');
    formData.append('password', 'admin');
    
    const request = new Request('http://localhost:3000/admin/login', {
      method: 'POST',
      body: formData,
    });
    
    const response = await router.handle(request);
    
    expect(response.status).toBe(302);
    expect(response.headers.get('location')).toBe('/admin/dashboard');
    expect(response.headers.get('set-cookie')).toContain('session=');
  });
  
  it('GET /admin/dashboard without session redirects to login', async () => {
    const request = new Request('http://localhost:3000/admin/dashboard');
    const response = await router.handle(request);
    
    expect(response.status).toBe(302);
    expect(response.headers.get('location')).toContain('/admin/login');
  });
});
```

## Implementation Phases

### Phase 1: Core Infrastructure ‚úÖ COMPLETE
- [x] Move container to `src/container.ts` with `set()` helper
- [x] Add `group()` method to Router class with RouteGroup proxy pattern
- [x] Add `use()` method to RouteGroup for group-level middleware
- [x] Create `config/` directory structure
- [x] Create `lib/session/index.ts` with container integration
- [x] Create `lib/session/stores/memory.ts`
- [x] Create `config/session.ts` with default configuration
- [x] Write tests for container and session management

### Phase 2: Authentication Middleware ‚úÖ COMPLETE
- [x] Create `lib/auth/middleware.ts` with flexible `requireAuth()`
- [x] Add `onUnauthorized` option to auth middleware
- [x] Add `redirectIfAuth()` middleware
- [x] Update types to include `Session` in `RequestContext`
- [x] Write tests for auth middleware

### Phase 3: Admin Panel UI ‚úÖ COMPLETE
- [x] Create `lib/admin/` directory structure
- [x] Create admin layout component (`lib/admin/ui/AdminLayout.tsx`) - no CSS
- [x] Create login handler (`lib/admin/handlers/login.tsx`)
- [x] Create LoginForm component (`lib/admin/ui/LoginForm.tsx`) - no CSS
- [x] Create authenticate handler (`lib/admin/handlers/authenticate.ts`)
- [x] Create dashboard handler (`lib/admin/handlers/dashboard.tsx`)
- [x] Create Dashboard component (`lib/admin/ui/Dashboard.tsx`) - no CSS
- [x] Create logout handler (`lib/admin/handlers/logout.ts`)
- [x] Test login flow end-to-end with native FormData

### Phase 4: AsyncLocalStorage Context System ‚úÖ COMPLETE
- [x] Create `lib/router/context.ts` with AsyncLocalStorage
- [x] Add `getRequestContext()` helper
- [x] Add `runWithContext()` helper
- [x] Update router to use `runWithContext()` for all requests
- [x] Update `ui()` helper to use `getRequestContext()`

### Phase 5: Layout Middleware System ‚úÖ COMPLETE
- [x] Create `lib/router/react/middleware.ts` with `withLayout()`
- [x] Update `lib/admin/routes.ts` to use `group.use(withLayout(AdminLayout))`
- [x] Update `ui()` helper to check `ctx.layout` from AsyncLocalStorage
- [x] Test layout system with admin routes
- [x] Verify single-line drop-in works

### Phase 6: Integration & Documentation ‚úÖ COMPLETE
- [x] Update example `src/routes.ts` to register admin routes
- [x] Write integration tests for complete admin flow
- [x] Add request context to RequestContext type
- [x] Add layout field to RequestContext type
- [x] Verify all tests pass

## Success Criteria

- [x] Service container works with lazy initialization
- [x] Container lives in `src/container.ts` (user can modify)
- [x] `config/session.ts` allows easy backend swapping
- [x] AsyncLocalStorage context system provides request-scoped data
- [x] Request context available via `getRequestContext()` anywhere in handler chain
- [x] `/admin/login` renders a login form using native HTML (no CSS)
- [x] Form submission with valid credentials creates a session
- [x] Form submission with invalid credentials shows error
- [x] Session cookie is HTTP-only and SameSite
- [x] `/admin/dashboard` redirects to login when not authenticated
- [x] `/admin/dashboard` shows dashboard when authenticated (no CSS)
- [x] POST `/admin/logout` destroys session and redirects to login
- [x] `router.group()` method uses proxy pattern (no code duplication)
- [x] `RouteGroup.use()` method adds group-level middleware
- [x] Auth middleware accepts `onUnauthorized` option
- [x] Admin handlers live in `lib/admin/` (drop-in feature)
- [x] `withLayout()` middleware sets layout in request context
- [x] `ui()` automatically uses layout from request context
- [x] Handlers don't need to pass context or layout to `ui()`
- [x] Layout system uses AsyncLocalStorage, not container
- [x] All tests pass
- [x] Native FormData used throughout (no JSON APIs for forms)
- [x] Single line drop-in: `router.group('/admin', adminRoutes)`

**Status**: ‚úÖ All success criteria met

## Open Questions

1. **Password hashing**: Use bcrypt or argon2? (Defer to Phase 2 - argon2 recommended)
2. **Remember me**: Should we add "remember me" functionality? (Phase 3)
3. **Password reset**: Email-based or admin-managed? (Separate spec)
4. **CSS approach**: When we add CSS, use scoped prefix or CSS modules? (Future decision)
5. **Logging system**: Implement configurable logging middleware? (Future - not in this spec)

## References

- MDN Web Docs: HTTP Cookies - https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
- MDN: FormData API - https://developer.mozilla.org/en-US/docs/Web/API/FormData
- OWASP Session Management Cheat Sheet - https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
- Web.dev: SameSite cookies explained - https://web.dev/samesite-cookies-explained/
- HTTP Spec: Safe Methods - https://www.rfc-editor.org/rfc/rfc9110.html#name-safe-methods
- Dependency Injection Pattern - https://en.wikipedia.org/wiki/Dependency_injection

---

**Status**: ‚úÖ Complete - Implementation Finished
**Key Achievements**: 
- ‚úÖ Complete admin authentication system with session management
- ‚úÖ AsyncLocalStorage-based request context (no prop drilling)
- ‚úÖ Layout middleware system using request context
- ‚úÖ RouteGroup with `use()` for group-level middleware
- ‚úÖ Drop-in admin panel (single line: `router.group('/admin', adminRoutes)`)
- ‚úÖ Container pattern for pluggable session backends
- ‚úÖ Native HTML forms (no JS required)
- ‚úÖ Clean separation of lib vs user code
- ‚úÖ Full test coverage for core functionality

**Implementation Highlights**:
- Session code in `lib/session/` (not `lib/auth/`)
- Context system via AsyncLocalStorage (not container)
- No `config/admin.ts` needed - layout via middleware
- `withLayout()` middleware for flexible layout configuration
- Request context accessible anywhere via `getRequestContext()`
- All handlers in `lib/admin/` for true drop-in experience

**Next Steps**: This spec is complete. See separate specs for:
- Content management and schemas
- Event sourcing implementation
- Search and SEO features
